<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SSYCarbonSearcher Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SSYCarbonSearcher Class Reference</h1><!-- doxytag: class="SSYCarbonSearcher" --><!-- doxytag: inherits="NSObject" -->This class provides a class method for searching the startup disk for files matching a given name, returning paths.  
<a href="#_details">More...</a>
<p>
<code>#import &lt;<a class="el" href="_s_s_y_carbon_searcher_8h-source.html">SSYCarbonSearcher.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for SSYCarbonSearcher:</div>
<div class="dynsection">

<p><center><img src="interface_s_s_y_carbon_searcher.png" usemap="#SSYCarbonSearcher_map" border="0" alt=""></center>
<map name="SSYCarbonSearcher_map">
</map>
</div>

<p>
<a href="class_s_s_y_carbon_searcher-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_carbon_searcher.html#e943f119cc173fadae03796c0041f837">catalogPathsForName:fullNameSearch:findDirectories:findFiles:maxFindsPerIteration:maxSecondsPerIteration:maxIterations:maxFindsGrandTotal:verbose:printResultsEachIteration:syncResults_p:asyncCallbackTarget:asyncCallbackSelector:err_p:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a synchronous or asynchronous search of the startup disk catalog, finding the full paths of files matching a given name.  <a href="#e943f119cc173fadae03796c0041f837"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class provides a class method for searching the startup disk for files matching a given name, returning paths. 
<p>
NSObject { }  This class uses Carbon's old File Manager. PBCatalogSearch[A]Sync() does the actual work. This is way faster than Unix 'find', but not as fast as a Spotlight search. However it is more comprehensive than a Spotlight search because (1) user cannot exclude directories using Spotlight's Preferences, (2) it searches inside packages. There may be other differences that I am not aware of.<p>
I believe this class should work at least down to Mac OS 10.3, but have not tested it in Mac OS 10.3.<p>
A unix command-line wrapper, CarbonSearch, and also a Cocoa application (windowless, prints to log), CarbonSearcherApp, are available to demonstrate the class and to use as a utility. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="e943f119cc173fadae03796c0041f837"></a><!-- doxytag: member="SSYCarbonSearcher::catalogPathsForName:fullNameSearch:findDirectories:findFiles:maxFindsPerIteration:maxSecondsPerIteration:maxIterations:maxFindsGrandTotal:verbose:printResultsEachIteration:syncResults_p:asyncCallbackTarget:asyncCallbackSelector:err_p:" ref="e943f119cc173fadae03796c0041f837" args="(NSString *searchString,[fullNameSearch] BOOL fullNameSearch,[findDirectories] BOOL findDirectories,[findFiles] BOOL findFiles,[maxFindsPerIteration] UInt32 maxFindsPerIteration,[maxSecondsPerIteration] float maxSecondsPerIteration,[maxIterations] int maxIterations,[maxFindsGrandTotal] UInt32 maxFindsGrandTotal,[verbose] BOOL verbose,[printResultsEachIteration] BOOL printResultsEachIteration,[syncResults_p] NSDictionary **syncResults,[asyncCallbackTarget] id asyncCallbackTarget,[asyncCallbackSelector] SEL asyncCallbackSelector,[err_p] OSErr *err_p)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) catalogPathsForName:           </td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>searchString</em></td>
        </tr>
        <tr>
          <td class="paramkey">fullNameSearch:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>fullNameSearch</em></td>
        </tr>
        <tr>
          <td class="paramkey">findDirectories:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>findDirectories</em></td>
        </tr>
        <tr>
          <td class="paramkey">findFiles:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>findFiles</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxFindsPerIteration:</td>
          <td></td>
          <td class="paramtype">(UInt32)&nbsp;</td>
          <td class="paramname"> <em>maxFindsPerIteration</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxSecondsPerIteration:</td>
          <td></td>
          <td class="paramtype">(float)&nbsp;</td>
          <td class="paramname"> <em>maxSecondsPerIteration</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxIterations:</td>
          <td></td>
          <td class="paramtype">(int)&nbsp;</td>
          <td class="paramname"> <em>maxIterations</em></td>
        </tr>
        <tr>
          <td class="paramkey">maxFindsGrandTotal:</td>
          <td></td>
          <td class="paramtype">(UInt32)&nbsp;</td>
          <td class="paramname"> <em>maxFindsGrandTotal</em></td>
        </tr>
        <tr>
          <td class="paramkey">verbose:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>verbose</em></td>
        </tr>
        <tr>
          <td class="paramkey">printResultsEachIteration:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>printResultsEachIteration</em></td>
        </tr>
        <tr>
          <td class="paramkey">syncResults_p:</td>
          <td></td>
          <td class="paramtype">(NSDictionary**)&nbsp;</td>
          <td class="paramname"> <em>syncResults</em></td>
        </tr>
        <tr>
          <td class="paramkey">asyncCallbackTarget:</td>
          <td></td>
          <td class="paramtype">(id)&nbsp;</td>
          <td class="paramname"> <em>asyncCallbackTarget</em></td>
        </tr>
        <tr>
          <td class="paramkey">asyncCallbackSelector:</td>
          <td></td>
          <td class="paramtype">(SEL)&nbsp;</td>
          <td class="paramname"> <em>asyncCallbackSelector</em></td>
        </tr>
        <tr>
          <td class="paramkey">err_p:</td>
          <td></td>
          <td class="paramtype">(OSErr*)&nbsp;</td>
          <td class="paramname"> <em>err_p</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs a synchronous or asynchronous search of the startup disk catalog, finding the full paths of files matching a given name. 
<p>
My apologies for having so many arguments, but believe me it's better than filling out a parameter block. Much of the complication comes from the fact that the search is broken up into partial searches called "iterations". This is necessary since the PBCatalogSearch[A]Sync() which does the actual work returns results in 'C' arrays which must be dimensioned to a finite size. In other words, if there are many results <a class="el" href="interfaceyou.html" title="Accessors generated dynamically by Core Data for Stark managed objects.">you</a> need to empty the bucket once in awhile. This can be thought of as "feature" in that <a class="el" href="interfaceyou.html" title="Accessors generated dynamically by Core Data for Stark managed objects.">you</a> can print partial results after each iteration. In this implementation, partial results just get printed to the console. If a non-NULL syncResults argument is provided, the search is performed synchronously (blocking the calling thread until the search is complete). If syncResults is NULL, the search is performed asynchronously (not blocking, using PBCatalogSearchAsync), and results are returned to the asyncCallbackTarget via the asyncCallbackSelector. Results will be returned for each iteration. The asynchronous mode is recommended in applcations where it is undesirable to freeze the user interface. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>searchString</em>&nbsp;</td><td>filename, or part of a filename, to be searched for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fullNameSearch</em>&nbsp;</td><td>If YES, narrowly filters results to require that filenames match the entire searchString. If NO, a partial match is sufficient. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>findDirectories</em>&nbsp;</td><td>If NO, directories will be excluded from results. If findDirectories is NO, then findFiles must be YES or an exception will be raised. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>findFiles</em>&nbsp;</td><td>If NO, regular files will be excluded from results. If findFiles is NO, then findDirectories must be YES or an exception will be raised. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxFindsPerIteration</em>&nbsp;</td><td>The maximum number of paths allowed to be found per iteration. When this is reached, another iteration is started. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxSecondsPerIteration</em>&nbsp;</td><td>The maximum time in seconds allowed per iteration. When this is reached, another iteration is started. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxIterations</em>&nbsp;</td><td>The maximum number of iterations allowed. When this is exceeded, the search is aborted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maxFindsGrandTotal</em>&nbsp;</td><td>The maximum number of paths allowed to be found. When this is exceeded, the search is aborted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>verbose</em>&nbsp;</td><td>If YES, prints diagnostics to console </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>printResultsEachIteration</em>&nbsp;</td><td>If YES, prints paths found after each iteration </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>syncResults</em>&nbsp;</td><td>If this argument is NULL, the search is run asynchronously (see Discussion). Otherwise, this should be a handle to an NSDictionary to which the results will be returned. The dictionary entries are the keys SSYCarbonSearcherResultsKeyXXXXXX. See "Constants" for a list of the keys and description of their values. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asyncCallbackTarget</em>&nbsp;</td><td>The object (NSObject) to which results messages will be sent, if searching asynchronously. This argument is required to be non-nil if searching asynchronously, syncResults=NULL. Otherwise, it is ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>asyncCallbackSelector</em>&nbsp;</td><td>The selector (method) via which results messages will be sent, if searching asynchronously. This argument is required to be non-NULL if searching asynchronously, syncResults=NULL. Otherwise, it is ignored. This selector must take one argument, an NSDictionary*, and return an integer. The NSDictionary will contain the SSYCarbonSearcherResultsKeyXXXX keys. The integer returned should be one of the enumeration constants in SSYCarbonSearcherContinueStyle. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>err_p</em>&nbsp;</td><td>If <a class="el" href="interfaceyou.html" title="Accessors generated dynamically by Core Data for Stark managed objects.">you</a> pass a pointer to an OSErr, on output it will point to the last OSErr value generated by File Manager functions. Note that a value of -1417, indicating errFSNoMoreItems, is normal when the search is completed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>For an asynchronous search, returns YES if the search was initiated with no errors and NO otherwise. For an synchronous search, returns YES if the search was completed with no errors and NO otherwise. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>Documents/Programming/ClassesObjC/<a class="el" href="_s_s_y_carbon_searcher_8h-source.html">SSYCarbonSearcher.h</a><li>Documents/Programming/ClassesObjC/SSYCarbonSearcher.m</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 17 16:43:05 2008 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>

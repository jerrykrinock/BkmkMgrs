<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>BookMacster: Starker Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Starker Class Reference</h1><!-- doxytag: class="Starker" -->Instantiated with a managed object context with Starks in it, <a class="el" href="interface_starker.html" title="Instantiated with a managed object context with Starks in it, Starker can do many...">Starker</a> can do many of the common manipulations <a class="el" href="interfaceyou.html" title="Accessors generated dynamically by Core Data for Stark managed objects.">you</a> need done on those Starks.  
<a href="#_details">More...</a>
<p>
<code>#import &lt;<a class="el" href="_starker_8h-source.html">Starker.h</a>&gt;</code>
<p>

<p>
<a href="class_starker-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#fe2d2b4012ad3a6ee403683afb3c3141">allBookmarksOnlySortedBy:matchingInNameOrURL:matchingTags:logic:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all starks whose type is classified as "bookmark", passing option name/url and tag filters, and sorted by a given sortKey.  <a href="#fe2d2b4012ad3a6ee403683afb3c3141"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6cdf2546b53485807ff3830eb6534506"></a><!-- doxytag: member="Starker::allNonhierarchicalStarks" ref="6cdf2546b53485807ff3830eb6534506" args="()" -->
(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#6cdf2546b53485807ff3830eb6534506">allNonhierarchicalStarks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all starks in the receiver's managed object context which should display in a flat, no-folders view. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1229c0a6b3b8eb37fc160d212295c6d8"></a><!-- doxytag: member="Starker::allNonRootStarks" ref="1229c0a6b3b8eb37fc160d212295c6d8" args="()" -->
(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#1229c0a6b3b8eb37fc160d212295c6d8">allNonRootStarks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all starks in the receiver's managed object context except the root stark. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c801cc032a5e50d78233e4a7ddfcf21f"></a><!-- doxytag: member="Starker::allSeparatorStarks" ref="c801cc032a5e50d78233e4a7ddfcf21f" args="()" -->
(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#c801cc032a5e50d78233e4a7ddfcf21f">allSeparatorStarks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all starks in the receiver's managed object context for which -sharypeValue returns SharypeSeparator. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSSet *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#bc41462f876cb564eff482c51e634ef8">allShortcuts</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a set of all the shortcuts existing in all of starks in the receiver's managed object context.  <a href="#bc41462f876cb564eff482c51e634ef8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f73619556ccab00cb5b4d1ed802d5812"></a><!-- doxytag: member="Starker::allSoftStarks" ref="f73619556ccab00cb5b4d1ed802d5812" args="()" -->
(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#f73619556ccab00cb5b4d1ed802d5812">allSoftStarks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all starks in the receiver's managed object context that are not hartainers; return NO to -isHartainer. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSCountedSet *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#97d71185bce7a12c705e88e7a47924cd">allTags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a NSCountedSet of all the tags existing in all of starks in the receiver's managed object context.  <a href="#97d71185bce7a12c705e88e7a47924cd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="97f76f8bb784adb13fd725e990998ca8"></a><!-- doxytag: member="Starker::bar" ref="97f76f8bb784adb13fd725e990998ca8" args="()" -->
(<a class="el" href="class_stark.html">Stark</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#97f76f8bb784adb13fd725e990998ca8">bar</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the receiver's Bookmarks Bar hartainer collection, or nil if the receiver does not have one. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#daca2fda1699477d0b3cbd3f1613b130">deleteAllObjects</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Deletes all of the starks in the receiver's managed object context and also sets the cached root instance variable to nil.￼.  <a href="#daca2fda1699477d0b3cbd3f1613b130"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d734d35c7a91bb8ebf16445d4023321c"></a><!-- doxytag: member="Starker::deleteStark:" ref="d734d35c7a91bb8ebf16445d4023321c" args="(Stark *stark)" -->
(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#d734d35c7a91bb8ebf16445d4023321c">deleteStark:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a single stark from the receiver's managed object context.￼. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#3d17b481943ce2a3ccd9d1e9613bf695">deleteStarks:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Delete a subset of the receiver's starks from the receiver's managed object context.￼.  <a href="#3d17b481943ce2a3ccd9d1e9613bf695"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(id)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#a6bc8eb2ce9f75157c0b3fcc8d669cf6">initWithManagedObjectContext:owner:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Designated Initializer for <a class="el" href="interface_starker.html" title="Instantiated with a managed object context with Starks in it, Starker can do many...">Starker</a> instances ￼.  <a href="#a6bc8eb2ce9f75157c0b3fcc8d669cf6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#4708f65cf0077599521812a5573e8e5a">insertStarkLikeStark:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">￼Inserts a new stark in the receiver's managed object context and sets its attributes to match those of an other stark.  <a href="#4708f65cf0077599521812a5573e8e5a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c9d7934838919f1c07a3de24019f1f2e"></a><!-- doxytag: member="Starker::matchedStarks" ref="c9d7934838919f1c07a3de24019f1f2e" args="()" -->
(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#c9d7934838919f1c07a3de24019f1f2e">matchedStarks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all of the receiver's Starks that have isMatched==YES. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ef8b7e68846767cd600ab5038c301351"></a><!-- doxytag: member="Starker::menu" ref="ef8b7e68846767cd600ab5038c301351" args="()" -->
(<a class="el" href="class_stark.html">Stark</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#ef8b7e68846767cd600ab5038c301351">menu</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the receiver's Bookmarks Menu hartainer collection, or nil if the receiver does not have one. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="class_stark.html">Stark</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#fb577d5ab759cfe1ac806592c2ee4117">newStark</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts a new stark into receiver's managed object context.  <a href="#fb577d5ab759cfe1ac806592c2ee4117"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="class_stark.html">Stark</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#684b153eda9128194d5432de135e1abb">ohared</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the receiver's Ohared (OmniWeb Shared) hartainer collection, or nil if the receiver does not have one.  <a href="#684b153eda9128194d5432de135e1abb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fc0ca854c289203b29ba54e3fcea4ae4"></a><!-- doxytag: member="Starker::processPendingChanges" ref="fc0ca854c289203b29ba54e3fcea4ae4" args="()" -->
(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#fc0ca854c289203b29ba54e3fcea4ae4">processPendingChanges</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends -processPendingChanges receiver's managed object context.￼. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="192bfe5cfee3de5793f028dcae3ea4b4"></a><!-- doxytag: member="Starker::save:" ref="192bfe5cfee3de5793f028dcae3ea4b4" args="(NSError **error)" -->
(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#192bfe5cfee3de5793f028dcae3ea4b4">save:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A wrapper for sending -save: to the receiver's managed object context. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7ad462e926b7a142ca20d22902a2f125"></a><!-- doxytag: member="Starker::setAllStarksNotMatched" ref="7ad462e926b7a142ca20d22902a2f125" args="()" -->
(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#7ad462e926b7a142ca20d22902a2f125">setAllStarksNotMatched</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the isMatched attribute to NO in all of the receiver's Starks to NO. ￼. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#d55434f50ba418c0da1f705826290d3d">setValue:forKey:inStarks:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the same new value for the same key in a collection of starks.  <a href="#d55434f50ba418c0da1f705826290d3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="class_stark.html">Stark</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#3c1b774cdc1371325f0768bac859df4c">starkOfSharype:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first stark found of a given sharype in the receiver's owner's manged object context, or nil if no such stark exists.  <a href="#3c1b774cdc1371325f0768bac859df4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSDictionary *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#f95610147961bd54e65714c250d97112">starksKeyedByExidForBrowid:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a dictionary of all starks in the receiver's managed object context which have an exid for a given browid.  <a href="#f95610147961bd54e65714c250d97112"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSDictionary *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#1e2df51e1815880ae1b2b339c801359a">starksKeyedByKey:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A "bulk" version of starkWithEqualValueForKey:asStark: which returns all starks in a convenient dictionary with only one fetch.  <a href="#1e2df51e1815880ae1b2b339c801359a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="class_stark.html">Stark</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#f68e618ff7532058e480e99ef40125f8">starkWithEqualValueForKey:asStark:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the first of the receiver's Starks whose value for a given key is equal to the value of the same key in another given Stark￼.  <a href="#f68e618ff7532058e480e99ef40125f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(<a class="el" href="class_stark.html">Stark</a> *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#043bec1f3d10734c4c2b6adacdafa9dd">unfiled</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the receiver's Bookmarks Unfiled hartainer collection, or nil if the receiver does not have one.  <a href="#043bec1f3d10734c4c2b6adacdafa9dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="867b017225ba7dc82d0dd1f705565021"></a><!-- doxytag: member="Starker::unmatchedLeaves" ref="867b017225ba7dc82d0dd1f705565021" args="()" -->
(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#867b017225ba7dc82d0dd1f705565021">unmatchedLeaves</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all of the receiver's Starks which have isMatched=NO and sharype one of the leaf coarse types. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ebe6bb1af19f279541638dbbb121f2ac"></a><!-- doxytag: member="Starker::unmatchedStarks" ref="ebe6bb1af19f279541638dbbb121f2ac" args="()" -->
(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">- <a class="el" href="interface_starker.html#ebe6bb1af19f279541638dbbb121f2ac">unmatchedStarks</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns all of the receiver's Starks that do not have isMatched==YES. <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="494ce92d64fc0b7d121781c9ae87b723"></a><!-- doxytag: member="Starker::areSortableItems:" ref="494ce92d64fc0b7d121781c9ae87b723" args="(NSArray *items)" -->
(NSInteger)&nbsp;</td><td class="memItemRight" valign="bottom">+ <b>areSortableItems:</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7f5728ca247fb3b5c99ee0473ce2c81"></a><!-- doxytag: member="Starker::countOfBookmarksInItems:" ref="b7f5728ca247fb3b5c99ee0473ce2c81" args="(NSArray *starks)" -->
(NSInteger)&nbsp;</td><td class="memItemRight" valign="bottom">+ <b>countOfBookmarksInItems:</b></td></tr>

<tr><td colspan="2"><br><h2>Properties</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="interface_browid.html">Browid</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_starker.html#ad670a0a7f814f16031594514cb0d005">browid</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The -browid of the receiver's -owner, or nil if the receiver's -owner does not respond to -browfile.  <a href="#ad670a0a7f814f16031594514cb0d005"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6ea1720ea5009a7a1b3003c8c59fd54b"></a><!-- doxytag: member="Starker::owner" ref="6ea1720ea5009a7a1b3003c8c59fd54b" args="" -->
NSObject&lt; <a class="el" href="protocol_startainer-p.html">Startainer</a>, <br class="typebreak">
SSYErrorHandler &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_starker.html#6ea1720ea5009a7a1b3003c8c59fd54b">owner</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The object which is using the receiver to store its Starks.&nbsp; A weak reference. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="class_stark.html">Stark</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="interface_starker.html#240831d09fe505069017793aa161c471">root</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the receiver's root <a class="el" href="class_stark.html" title="A Stored Bookmark Managed Object.">Stark</a>, creating one if none exists.  <a href="#240831d09fe505069017793aa161c471"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Instantiated with a managed object context with Starks in it, <a class="el" href="interface_starker.html" title="Instantiated with a managed object context with Starks in it, Starker can do many...">Starker</a> can do many of the common manipulations <a class="el" href="interfaceyou.html" title="Accessors generated dynamically by Core Data for Stark managed objects.">you</a> need done on those Starks. 
<p>
This object is used in three situations: as either the starker or the localStarker for an <a class="el" href="interface_extore.html" title="Reads/Writes bookmarks from/to an external store.">Extore</a>, or the -managedObjectContext of a <a class="el" href="class_bookshelf.html" title="BookMacster&#39;s default Document. A &quot;Bookshelf&quot; is a place for storing...">Bookshelf</a> document. This class was written because the three situations described all require some common methods for accessing Starks and collections of Starks.<p>
The receiver's managed object context may contain other objects besides Starks. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="fe2d2b4012ad3a6ee403683afb3c3141"></a><!-- doxytag: member="Starker::allBookmarksOnlySortedBy:matchingInNameOrURL:matchingTags:logic:" ref="fe2d2b4012ad3a6ee403683afb3c3141" args="(NSString *sortKey,[matchingInNameOrURL] NSString *filterString,[matchingTags] NSSet *filterTags,[logic] int filterLogic)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSArray *) allBookmarksOnlySortedBy:           </td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>sortKey</em></td>
        </tr>
        <tr>
          <td class="paramkey">matchingInNameOrURL:</td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>filterString</em></td>
        </tr>
        <tr>
          <td class="paramkey">matchingTags:</td>
          <td></td>
          <td class="paramtype">(NSSet*)&nbsp;</td>
          <td class="paramname"> <em>filterTags</em></td>
        </tr>
        <tr>
          <td class="paramkey">logic:</td>
          <td></td>
          <td class="paramtype">(int)&nbsp;</td>
          <td class="paramname"> <em>filterLogic</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns all starks whose type is classified as "bookmark", passing option name/url and tag filters, and sorted by a given sortKey. 
<p>
The "bookmark" classification is defined by -[<a class="el" href="class_stark.html" title="A Stored Bookmark Managed Object.">Stark</a> classifyBySharypeDeeply:hartainers:softFolders:bookmarks:separators:]. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sortKey</em>&nbsp;</td><td>The sort key with which the results will be sorted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filterString</em>&nbsp;</td><td>A string which must appear in the name or url in order for bookmarks to pass the name filter </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filterTags</em>&nbsp;</td><td>The set of tags used in the tag filter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filterLogic</em>&nbsp;</td><td>If 0, the filterTags parameter is ignored and not filtering by tags is done.&nbsp; If 1, the tag filter will pass only starks that have all of the tags in the filterTags set.&nbsp; </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An array of filtered, sorted starks. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc41462f876cb564eff482c51e634ef8"></a><!-- doxytag: member="Starker::allShortcuts" ref="bc41462f876cb564eff482c51e634ef8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSSet *) allShortcuts           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a set of all the shortcuts existing in all of starks in the receiver's managed object context. 
<p>
A set, by definition, has all of its duplicates coalesced into one.&nbsp; However, duplicate shortcuts should not be allowed anyhow. 
</div>
</div><p>
<a class="anchor" name="97d71185bce7a12c705e88e7a47924cd"></a><!-- doxytag: member="Starker::allTags" ref="97d71185bce7a12c705e88e7a47924cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSCountedSet *) allTags           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a NSCountedSet of all the tags existing in all of starks in the receiver's managed object context. 
<p>
An NSCountedSet indicates item counts by having the same item appear multiple times in the set.&nbsp; If <a class="el" href="interfaceyou.html" title="Accessors generated dynamically by Core Data for Stark managed objects.">you</a> want a set of distinct objects, use [NSSet setWithSet:[someStarker allTags]]. 
</div>
</div><p>
<a class="anchor" name="daca2fda1699477d0b3cbd3f1613b130"></a><!-- doxytag: member="Starker::deleteAllObjects" ref="daca2fda1699477d0b3cbd3f1613b130" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) deleteAllObjects           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Deletes all of the starks in the receiver's managed object context and also sets the cached root instance variable to nil.￼. 
<p>
￼ According to <a href="http://www.cocoabuilder.com/archive/message/cocoa/2006/11/15/174531,">http://www.cocoabuilder.com/archive/message/cocoa/2006/11/15/174531,</a> the Great mmalc seemed to think it was better, albeit slower, to delete all objects in the store, rather than replacing the store file. Actually, this is not possible in the general case anyhow, when the store may include other Starker's Starks or other entities. 
</div>
</div><p>
<a class="anchor" name="3d17b481943ce2a3ccd9d1e9613bf695"></a><!-- doxytag: member="Starker::deleteStarks:" ref="3d17b481943ce2a3ccd9d1e9613bf695" args="(id starks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) deleteStarks:           </td>
          <td></td>
          <td class="paramtype">(id)&nbsp;</td>
          <td class="paramname"> <em>starks</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete a subset of the receiver's starks from the receiver's managed object context.￼. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>starks</em>&nbsp;</td><td>May be either an NSArray* or NSSet*. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a6bc8eb2ce9f75157c0b3fcc8d669cf6"></a><!-- doxytag: member="Starker::initWithManagedObjectContext:owner:" ref="a6bc8eb2ce9f75157c0b3fcc8d669cf6" args="(NSManagedObjectContext *managedObjectContext_,[owner] NSObject&lt; Startainer, SSYErrorHandler &gt; *owner_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (id) initWithManagedObjectContext:           </td>
          <td></td>
          <td class="paramtype">(NSManagedObjectContext*)&nbsp;</td>
          <td class="paramname"> <em>managedObjectContext_</em></td>
        </tr>
        <tr>
          <td class="paramkey">owner:</td>
          <td></td>
          <td class="paramtype">(NSObject &lt;<a class="el" href="protocol_startainer-p.html">Startainer</a>, SSYErrorHandler&gt; *)&nbsp;</td>
          <td class="paramname"> <em>owner_</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Designated Initializer for <a class="el" href="interface_starker.html" title="Instantiated with a managed object context with Starks in it, Starker can do many...">Starker</a> instances ￼. 
<p>
Both arguments are required. If either is nil, this method will return nil. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>managedObjectContext</em>&nbsp;</td><td>See class properties for documentation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>owner</em>&nbsp;</td><td>See class properties for documentation. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>￼The receiver, or nil if something failed. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4708f65cf0077599521812a5573e8e5a"></a><!-- doxytag: member="Starker::insertStarkLikeStark:" ref="4708f65cf0077599521812a5573e8e5a" args="(Stark *otherStark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) insertStarkLikeStark:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_stark.html">Stark</a>*)&nbsp;</td>
          <td class="paramname"> <em>otherStark</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
￼Inserts a new stark in the receiver's managed object context and sets its attributes to match those of an other stark. 
<p>
Enumerates through the attributes of otherStark.&nbsp; For each non-nil value found, sets the same value for the same attribute key in the new stark.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>otherStark</em>&nbsp;</td><td>The stark whose attributes are to be copied. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fb577d5ab759cfe1ac806592c2ee4117"></a><!-- doxytag: member="Starker::newStark" ref="fb577d5ab759cfe1ac806592c2ee4117" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_stark.html">Stark</a> *) newStark           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inserts a new stark into receiver's managed object context. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The newly-inserted stark </dd></dl>

</div>
</div><p>
<a class="anchor" name="684b153eda9128194d5432de135e1abb"></a><!-- doxytag: member="Starker::ohared" ref="684b153eda9128194d5432de135e1abb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_stark.html">Stark</a> *) ohared           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the receiver's Ohared (OmniWeb Shared) hartainer collection, or nil if the receiver does not have one. 
<p>
This hartainer collection is nil for most Extores. 
</div>
</div><p>
<a class="anchor" name="d55434f50ba418c0da1f705826290d3d"></a><!-- doxytag: member="Starker::setValue:forKey:inStarks:" ref="d55434f50ba418c0da1f705826290d3d" args="(id value,[forKey] NSString *key,[inStarks] id starks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (void) setValue:           </td>
          <td></td>
          <td class="paramtype">(id)&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
        </tr>
        <tr>
          <td class="paramkey">forKey:</td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
        </tr>
        <tr>
          <td class="paramkey">inStarks:</td>
          <td></td>
          <td class="paramtype">(id)&nbsp;</td>
          <td class="paramname"> <em>starks</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the same new value for the same key in a collection of starks. 
<p>
Begins and ends an undo grouping. This may be unnecessary because, according to -[NSUndoManager beginUndoGrouping] documentation, "By default undo groups are begun automatically at the start of the event loop". All starks in the 'starks' parameter should be in the same managed object context because the managed object context is obtained from the first stark in starks. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The new value to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key for which to set the value </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>starks</em>&nbsp;</td><td>The NSArray of starks which are to be affected. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3c1b774cdc1371325f0768bac859df4c"></a><!-- doxytag: member="Starker::starkOfSharype:" ref="3c1b774cdc1371325f0768bac859df4c" args="(Sharype sharype)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_stark.html">Stark</a> *) starkOfSharype:           </td>
          <td></td>
          <td class="paramtype">(Sharype)&nbsp;</td>
          <td class="paramname"> <em>sharype</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the first stark found of a given sharype in the receiver's owner's manged object context, or nil if no such stark exists. 
<p>
The intended use is to get the hartainers. 
</div>
</div><p>
<a class="anchor" name="f95610147961bd54e65714c250d97112"></a><!-- doxytag: member="Starker::starksKeyedByExidForBrowid:" ref="f95610147961bd54e65714c250d97112" args="(Browid *browid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSDictionary *) starksKeyedByExidForBrowid:           </td>
          <td></td>
          <td class="paramtype">(<a class="el" href="interface_browid.html">Browid</a>*)&nbsp;</td>
          <td class="paramname"> <em>browid</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a dictionary of all starks in the receiver's managed object context which have an exid for a given browid. 
<p>
Use this method when <a class="el" href="interfaceyou.html" title="Accessors generated dynamically by Core Data for Stark managed objects.">you</a> need to get many starks each matching a given exid for a single browid.&nbsp; It is efficient because only one fetch is done.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>browid</em>&nbsp;</td><td>The browid for which each returned stark must have an exid </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A dictionary of starks, keyed by their exids for the given browid </dd></dl>

</div>
</div><p>
<a class="anchor" name="1e2df51e1815880ae1b2b339c801359a"></a><!-- doxytag: member="Starker::starksKeyedByKey:" ref="1e2df51e1815880ae1b2b339c801359a" args="(NSString *key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (NSDictionary *) starksKeyedByKey:           </td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>key</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A "bulk" version of starkWithEqualValueForKey:asStark: which returns all starks in a convenient dictionary with only one fetch. 
<p>
Starks which have a nil value for the given key will be omitted from the result. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key whose values will become keys in the result.&nbsp; Of course, the type of these values must be suitable to be a dictionary key.&nbsp; </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f68e618ff7532058e480e99ef40125f8"></a><!-- doxytag: member="Starker::starkWithEqualValueForKey:asStark:" ref="f68e618ff7532058e480e99ef40125f8" args="(NSString *key,[asStark] Stark *stark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_stark.html">Stark</a> *) starkWithEqualValueForKey:           </td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
        </tr>
        <tr>
          <td class="paramkey">asStark:</td>
          <td></td>
          <td class="paramtype">(<a class="el" href="class_stark.html">Stark</a>*)&nbsp;</td>
          <td class="paramname"> <em>stark</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the first of the receiver's Starks whose value for a given key is equal to the value of the same key in another given Stark￼. 
<p>
Typically, the <a class="el" href="class_stark.html" title="A Stored Bookmark Managed Object.">Stark</a> argument will belong to a different managed object context. This method is thus used to find <em>corresponding</em> or <em>matching</em> Starks in different managed object contexts.<p>
This implementation uses -valueForKey: on stark.&nbsp; It might be cheaper to change the key argument type to SEL, and use -performSelector: instead??<p>
This method requires a fetch. If you're thinking of using it in a loop, use starksKeyedByKey: instead, for efficiency. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The key whose value is to be matched. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>stark</em>&nbsp;</td><td>The other stark whose value is to be matched. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="043bec1f3d10734c4c2b6adacdafa9dd"></a><!-- doxytag: member="Starker::unfiled" ref="043bec1f3d10734c4c2b6adacdafa9dd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_stark.html">Stark</a> *) unfiled           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the receiver's Bookmarks Unfiled hartainer collection, or nil if the receiver does not have one. 
<p>
This hartainer collection is nil for most Extores. 
</div>
</div><p>
<hr><h2>Property Documentation</h2>
<a class="anchor" name="ad670a0a7f814f16031594514cb0d005"></a><!-- doxytag: member="Starker::browid" ref="ad670a0a7f814f16031594514cb0d005" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="interface_browid.html">Browid</a> *) browid<code> [read, retain]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The -browid of the receiver's -owner, or nil if the receiver's -owner does not respond to -browfile. 
<p>
I had previously used this to filter starks in general; however at this time it is not used. 
</div>
</div><p>
<a class="anchor" name="240831d09fe505069017793aa161c471"></a><!-- doxytag: member="Starker::root" ref="240831d09fe505069017793aa161c471" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">- (<a class="el" href="class_stark.html">Stark</a> *) root<code> [read, retain]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the receiver's root <a class="el" href="class_stark.html" title="A Stored Bookmark Managed Object.">Stark</a>, creating one if none exists. 
<p>
<a class="el" href="class_bookshelf.html" title="BookMacster&#39;s default Document. A &quot;Bookshelf&quot; is a place for storing...">Bookshelf</a> documents synced in from nonhierarchical sources will have all their items at root, and therefore when the outline is reloaded, if the view is is to displayFolders = YES, [BookshelfOutlineDataSource outlineView:child:ofItem:] will be invoked for each item, which will invoke this method, which will do a fetch.&nbsp; In an early prototype, displaying a document with 1161 bookmarks at root spent 3:45 min:sec just fetching root.&nbsp; So, to eliminate that, this method caches the root in an instance variable.<p>
We can get away with simply caching it because, as far as I can figure, once we have a root, it will never be replaced with a new root during the life of a starker.&nbsp; If this assertion were not true, this would get much more yucky. 
</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>/Users/jk/Documents/Programming/Projects/BookMacster/<a class="el" href="_starker_8h-source.html">Starker.h</a><li>/Users/jk/Documents/Programming/Projects/BookMacster/Starker.m</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon May 11 20:36:39 2009 for BookMacster by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>

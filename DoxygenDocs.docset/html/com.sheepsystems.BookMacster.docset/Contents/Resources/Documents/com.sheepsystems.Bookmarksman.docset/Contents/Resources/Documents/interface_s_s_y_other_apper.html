<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>SSYOtherApper Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>SSYOtherApper Class Reference</h1><!-- doxytag: class="SSYOtherApper" --><!-- doxytag: inherits="NSObject" -->A class of class methods for observing and controlling other applications.  
<a href="#_details">More...</a>
<p>
<code>#import &lt;<a class="el" href="_s_s_y_other_apper_8h-source.html">SSYOtherApper.h</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for SSYOtherApper:</div>
<div class="dynsection">

<p><center><img src="interface_s_s_y_other_apper.png" usemap="#SSYOtherApper_map" border="0" alt=""></center>
<map name="SSYOtherApper_map">
</map>
</div>

<p>
<a href="class_s_s_y_other_apper-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(pid_t)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#9a84904467601f670f918ca4ca44b23c">pidOfThisUsersAppWithBundleIdentifier:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns unix process ID (PID) of running app with given bundleIdentifier and the same user ID as this process.  <a href="#9a84904467601f670f918ca4ca44b23c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(pid_t)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#e9bd22bf08e408c430ff4e78837b5f50">pidOfRunningExecutableName:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns unix process ID (PID) of running app with given executable name.  <a href="#e9bd22bf08e408c430ff4e78837b5f50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSString *)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#0dc80eea85ed01896cb7b48ced64951e">versionStringForAppName:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets both version strings for an application with a given name and formats them into one string: "CFBundleShortVersionString (CFBundleVersion)".  <a href="#0dc80eea85ed01896cb7b48ced64951e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(pid_t)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#b9b485324f49ce4133926b819c96b2d1">pidOfThisUsersProcessNamed:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the unix process ID (pid) of a process with a given process name which must have the same user id as this process.  <a href="#b9b485324f49ce4133926b819c96b2d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(NSArray *)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#d90f09ff0b3b2fe51bb9753781098256">runningExecutablesUsersAndPIDs</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns an array with one element for each running executable, with each element being a dictionary with three key/value pairs: @"pidString", @"user", and @"command".  <a href="#d90f09ff0b3b2fe51bb9753781098256"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(struct ProcessSerialNumber)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#01c7b19bc9f1d866accecc1181524083">processSerialNumberForProcessIDNumber:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the process serial number given a unix process ID (pid).  <a href="#01c7b19bc9f1d866accecc1181524083"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(pid_t)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#2c2e6184773c20691af5e7b4ad77d114">pidOfThisUsersProcessWithBundlePath:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the unix process identifier (pid) of a process with a given bundle path with the same user ID as the current process.  <a href="#2c2e6184773c20691af5e7b4ad77d114"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#124f0f431084815f973c193d2d840f60">quitThisUsersAppWithPID:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds a running application, owned by the current user, with a given unix process identifier (pid) sends that app a "quit application" Apple Event message, and returns immediately.  <a href="#124f0f431084815f973c193d2d840f60"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#66c87ff12481240baaa238b739c4e96d">quitThisUsersAppWithPID:timeout:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds a running app, owned by the current user, with a given unix pid, sends it a "quit application" Apple Event message, and returns when the app is quit or timeout occurs, whichever comes first.  <a href="#66c87ff12481240baaa238b739c4e96d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#75d43509eff771647fb55f6f51cfc0fd">quitThisUsersAppWithBundleIdentifier:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds a running application, owned by the current user, with a given bundle identifier, sends that app a "quit application" Apple Event message, and returns immediately.  <a href="#75d43509eff771647fb55f6f51cfc0fd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#00f9c0308851443ba4dc51bde1f9dd5d">quitThisUsersAppWithBundleIdentifier:timeout:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds a running app, owned by the current user, with a given bundle identifier, sends it a "quit application" Apple Event message, and returns when the app is quit or timeout occurs, whichever comes first.  <a href="#00f9c0308851443ba4dc51bde1f9dd5d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(void)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#2f92b71badc09ac130766ad732c01f3d">killProcessPID:waitUntilExit:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Kills a process given its unix process identifier (pid).  <a href="#2f92b71badc09ac130766ad732c01f3d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">(BOOL)&nbsp;</td><td class="memItemRight" valign="bottom">+ <a class="el" href="interface_s_s_y_other_apper.html#b87815ef795c287fdc5a2c236475181f">killThisUsersAppWithBundleIdentifier:timeout:</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds a running app, owned by the current user, with a given bundle identifier, sends it a "kill -9" BSD signal, and returns when the app is killed or timeout occurs, whichever comes first.  <a href="#b87815ef795c287fdc5a2c236475181f"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A class of class methods for observing and controlling other applications. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="2f92b71badc09ac130766ad732c01f3d"></a><!-- doxytag: member="SSYOtherApper::killProcessPID:waitUntilExit:" ref="2f92b71badc09ac130766ad732c01f3d" args="(pid_t pid,[waitUntilExit] BOOL wait)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (void) killProcessPID:           </td>
          <td></td>
          <td class="paramtype">(pid_t)&nbsp;</td>
          <td class="paramname"> <em>pid</em></td>
        </tr>
        <tr>
          <td class="paramkey">waitUntilExit:</td>
          <td></td>
          <td class="paramtype">(BOOL)&nbsp;</td>
          <td class="paramname"> <em>wait</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Kills a process given its unix process identifier (pid). 
<p>
Kills the process using unix 'kill -9' <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td>The unix process identifier (pid) of the target process </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>waitUntilDone</em>&nbsp;</td><td>YES if this method should not return until the 'kill' process completes. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="b87815ef795c287fdc5a2c236475181f"></a><!-- doxytag: member="SSYOtherApper::killThisUsersAppWithBundleIdentifier:timeout:" ref="b87815ef795c287fdc5a2c236475181f" args="(NSString *bundleIdentifier,[timeout] NSTimeInterval timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) killThisUsersAppWithBundleIdentifier:           </td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>bundleIdentifier</em></td>
        </tr>
        <tr>
          <td class="paramkey">timeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds a running app, owned by the current user, with a given bundle identifier, sends it a "kill -9" BSD signal, and returns when the app is killed or timeout occurs, whichever comes first. 
<p>
May block its thread up to the timeout. Sleeps for 0.5 seconds between polls. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bundleIdentifier</em>&nbsp;</td><td>The bundle identifier of the application to be killed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>YES if the target app was not running, or if it dies within the allowed timeout. NO if app was still running when timeout expired. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e9bd22bf08e408c430ff4e78837b5f50"></a><!-- doxytag: member="SSYOtherApper::pidOfRunningExecutableName:" ref="e9bd22bf08e408c430ff4e78837b5f50" args="(NSString *executableName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (pid_t) pidOfRunningExecutableName:           </td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>executableName</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns unix process ID (PID) of running app with given executable name. 
<p>
If no such qualified process exists, or if executableName is nil, returns 0. If more than one such process exists, returns the first one found. Note that this method considers all processes for all users: anything that shows by executing the unix 'ps' command. It launches an NSTask to do this; therefore AppKit is not required. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>executableName</em>&nbsp;</td><td>The last component of the process' command path. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The unix process identifier (pid), or 0 if no qualifying process exists. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9a84904467601f670f918ca4ca44b23c"></a><!-- doxytag: member="SSYOtherApper::pidOfThisUsersAppWithBundleIdentifier:" ref="9a84904467601f670f918ca4ca44b23c" args="(NSString *bundleIdentifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (pid_t) pidOfThisUsersAppWithBundleIdentifier:           </td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>bundleIdentifier</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns unix process ID (PID) of running app with given bundleIdentifier and the same user ID as this process. 
<p>
If no such qualified process exists, or if bundleIdentifier is nil, returns 0. The target app must be a normal GUI app, not a faceless background application. This method invokes NSWorkspace and thus requires Cocoa AppKit. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bundleIdentifier</em>&nbsp;</td><td>The bundle identifier that the target app must have </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The unix process identifier (pid), or 0 if no qualifying process exists. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b9b485324f49ce4133926b819c96b2d1"></a><!-- doxytag: member="SSYOtherApper::pidOfThisUsersProcessNamed:" ref="b9b485324f49ce4133926b819c96b2d1" args="(NSString *processName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (pid_t) pidOfThisUsersProcessNamed:           </td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>processName</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the unix process ID (pid) of a process with a given process name which must have the same user id as this process. 
<p>
If no such process exists, returns 0. I think that the name is the CFBundleName, but it may be CFExecutableName. Finds regular applications as well as faceless background applications. Uses Carbon &gt; Process Manager 
</div>
</div><p>
<a class="anchor" name="2c2e6184773c20691af5e7b4ad77d114"></a><!-- doxytag: member="SSYOtherApper::pidOfThisUsersProcessWithBundlePath:" ref="2c2e6184773c20691af5e7b4ad77d114" args="(NSString *bundlePath)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (pid_t) pidOfThisUsersProcessWithBundlePath:           </td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>bundlePath</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the unix process identifier (pid) of a process with a given bundle path with the same user ID as the current process. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bundlePath</em>&nbsp;</td><td>The bundle path with the result must have </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The pid of the target process, or 0 if no qualifying process exists. </dd></dl>

</div>
</div><p>
<a class="anchor" name="01c7b19bc9f1d866accecc1181524083"></a><!-- doxytag: member="SSYOtherApper::processSerialNumberForProcessIDNumber:" ref="01c7b19bc9f1d866accecc1181524083" args="(pid_t pid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (struct ProcessSerialNumber) processSerialNumberForProcessIDNumber:           </td>
          <td></td>
          <td class="paramtype">(pid_t)&nbsp;</td>
          <td class="paramname"> <em>pid</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the process serial number given a unix process ID (pid). 
<p>
Invokes NSWorkspace, and thus requires AppKit.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pid</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The process serial number of the target process, or struct values {0,0} if no such process exists. </dd></dl>

</div>
</div><p>
<a class="anchor" name="75d43509eff771647fb55f6f51cfc0fd"></a><!-- doxytag: member="SSYOtherApper::quitThisUsersAppWithBundleIdentifier:" ref="75d43509eff771647fb55f6f51cfc0fd" args="(NSString *bundleIdentifier)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) quitThisUsersAppWithBundleIdentifier:           </td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>bundleIdentifier</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds a running application, owned by the current user, with a given bundle identifier, sends that app a "quit application" Apple Event message, and returns immediately. 
<p>
Does not wait or test to see if the requested app did quit. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bundleIdentifier</em>&nbsp;</td><td>The bundle identifier of the application to be quit. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>YES if it was able to find the app with the targetPID, send it a "quit" AppleEvent, and event returned without error. Otherwise, NO. Does not indicate whether or not the target app actually did quit. </dd></dl>

</div>
</div><p>
<a class="anchor" name="00f9c0308851443ba4dc51bde1f9dd5d"></a><!-- doxytag: member="SSYOtherApper::quitThisUsersAppWithBundleIdentifier:timeout:" ref="00f9c0308851443ba4dc51bde1f9dd5d" args="(NSString *bundleIdentifier,[timeout] NSTimeInterval timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) quitThisUsersAppWithBundleIdentifier:           </td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>bundleIdentifier</em></td>
        </tr>
        <tr>
          <td class="paramkey">timeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds a running app, owned by the current user, with a given bundle identifier, sends it a "quit application" Apple Event message, and returns when the app is quit or timeout occurs, whichever comes first. 
<p>
May block its thread up to the timeout. Sleeps for 0.5 seconds between polls. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bundleIdentifier</em>&nbsp;</td><td>The bundle identifier of the application to be quit. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>YES if the target app was not running, or if it quit within the allowed timeout. NO if app was still running when timeout expired. </dd></dl>

</div>
</div><p>
<a class="anchor" name="124f0f431084815f973c193d2d840f60"></a><!-- doxytag: member="SSYOtherApper::quitThisUsersAppWithPID:" ref="124f0f431084815f973c193d2d840f60" args="(pid_t targetPID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) quitThisUsersAppWithPID:           </td>
          <td></td>
          <td class="paramtype">(pid_t)&nbsp;</td>
          <td class="paramname"> <em>targetPID</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds a running application, owned by the current user, with a given unix process identifier (pid) sends that app a "quit application" Apple Event message, and returns immediately. 
<p>
Does not wait or test to see if the requested app did quit. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>targetPID</em>&nbsp;</td><td>The unix process identifier of the application to be quit. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>YES if it was able to find the app with the targetPID, send it a "quit" AppleEvent, and event returned without error. Otherwise, NO. Does not indicate whether or not the target app actually did quit. </dd></dl>

</div>
</div><p>
<a class="anchor" name="66c87ff12481240baaa238b739c4e96d"></a><!-- doxytag: member="SSYOtherApper::quitThisUsersAppWithPID:timeout:" ref="66c87ff12481240baaa238b739c4e96d" args="(pid_t targetPID,[timeout] NSTimeInterval timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (BOOL) quitThisUsersAppWithPID:           </td>
          <td></td>
          <td class="paramtype">(pid_t)&nbsp;</td>
          <td class="paramname"> <em>targetPID</em></td>
        </tr>
        <tr>
          <td class="paramkey">timeout:</td>
          <td></td>
          <td class="paramtype">(NSTimeInterval)&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds a running app, owned by the current user, with a given unix pid, sends it a "quit application" Apple Event message, and returns when the app is quit or timeout occurs, whichever comes first. 
<p>
May block its thread up to the timeout. Sleeps for 0.5 seconds between polls. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>targetPID</em>&nbsp;</td><td>The unix process identifier of the application to be quit. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>YES if the target app was not running, or if it quit within the allowed timeout. NO if app was still running when timeout expired. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d90f09ff0b3b2fe51bb9753781098256"></a><!-- doxytag: member="SSYOtherApper::runningExecutablesUsersAndPIDs" ref="d90f09ff0b3b2fe51bb9753781098256" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSArray *) runningExecutablesUsersAndPIDs           </td>
          <td></td>
          <td class="paramname">          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an array with one element for each running executable, with each element being a dictionary with three key/value pairs: @"pidString", @"user", and @"command". 
<p>
This method uses the unix "ps" instead of [[NSWorkspace sharedWorkspace] launchedApplications] The "advantage" of this is that it does not use AppKit, therefore does not invoke WindowServer, therefore does not raise an exception if the user is not the console user. The disadvantage is that it uses NSTask, and did not work in finding Bookwatchdog for user Michael Sherwin &lt;<a href="mailto:mdsherwin@mac.com">mdsherwin@mac.com</a>&gt; <dl class="return" compact><dt><b>Returns:</b></dt><dd>The array of information. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0dc80eea85ed01896cb7b48ced64951e"></a><!-- doxytag: member="SSYOtherApper::versionStringForAppName:" ref="0dc80eea85ed01896cb7b48ced64951e" args="(NSString *appName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">+ (NSString *) versionStringForAppName:           </td>
          <td></td>
          <td class="paramtype">(NSString*)&nbsp;</td>
          <td class="paramname"> <em>appName</em>          </td>
          <td>&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets both version strings for an application with a given name and formats them into one string: "CFBundleShortVersionString (CFBundleVersion)". 
<p>
Uses NSWorkspace, thus requires the Cocoa AppKit. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>appName</em>&nbsp;</td><td>The name of the target application. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The string as described, or " ()" of the named application could not be found. </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following files:<ul>
<li>Documents/Programming/ClassesObjC/<a class="el" href="_s_s_y_other_apper_8h-source.html">SSYOtherApper.h</a><li>Documents/Programming/ClassesObjC/SSYOtherApper.m</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 17 16:43:06 2008 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>

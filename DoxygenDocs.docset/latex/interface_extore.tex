\hypertarget{interface_extore}{
\section{Extore Class Reference}
\label{interface_extore}\index{Extore@{Extore}}
}
Reads/Writes bookmarks from/to an external store.  


{\tt \#import $<$Extore.h$>$}

Inheritance diagram for Extore::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2cm]{interface_extore}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{CompactItemize}
\item 
\hypertarget{interface_extore_f0c7e2be297067e0d709fbff462a12dc}{
(BOOL) - \hyperlink{interface_extore_f0c7e2be297067e0d709fbff462a12dc}{allowsSeparators}}
\label{interface_extore_f0c7e2be297067e0d709fbff462a12dc}

\begin{CompactList}\small\item\em Returns YES if the receiver's ownerApp supports separators; un-named lines between items; and NO if it does not. \item\end{CompactList}\item 
\hypertarget{interface_extore_abadc7a18d485037807066bfa7a33c98}{
(BOOL) - \hyperlink{interface_extore_abadc7a18d485037807066bfa7a33c98}{bookmarksAreInOneFile}}
\label{interface_extore_abadc7a18d485037807066bfa7a33c98}

\begin{CompactList}\small\item\em Returns whether or not the receiver's browser stores the bookmarks in one file, or whether the receivers web service stores the bookmarks at a single uri. \item\end{CompactList}\item 
\hypertarget{interface_extore_27b6da9b6908ad801dc464d696d9d235}{
(NSBundle $\ast$) - \textbf{browserBundle}}
\label{interface_extore_27b6da9b6908ad801dc464d696d9d235}

\item 
\hypertarget{interface_extore_db1fbc468a7ba309bf7a98ced4f3bca0}{
(NSString $\ast$) - \hyperlink{interface_extore_db1fbc468a7ba309bf7a98ced4f3bca0}{browserBundleIdentifier}}
\label{interface_extore_db1fbc468a7ba309bf7a98ced4f3bca0}

\begin{CompactList}\small\item\em Returns the bundle identifier of the receiver's ownerApp. \item\end{CompactList}\item 
\hypertarget{interface_extore_e3a45c62dea92893e79bfaeaa1bfc065}{
(BOOL) - \hyperlink{interface_extore_e3a45c62dea92893e79bfaeaa1bfc065}{canCreateNewDocuments}}
\label{interface_extore_e3a45c62dea92893e79bfaeaa1bfc065}

\begin{CompactList}\small\item\em Returns whether or not the receiver's \hyperlink{interface_extore}{Extore} can create a new, empty document in its browser's file format and later save it to the hard disk. \item\end{CompactList}\item 
\hypertarget{interface_extore_08b8e02066363b52a7c23992dde065bb}{
(BOOL) - \hyperlink{interface_extore_08b8e02066363b52a7c23992dde065bb}{catchesChangesDuringSave}}
\label{interface_extore_08b8e02066363b52a7c23992dde065bb}

\begin{CompactList}\small\item\em Returns whether or not the receiver's \hyperlink{class_bookshelf}{Bookshelf} will increment its change count if changes are made in this application during execution of a Sync Out command. \item\end{CompactList}\item 
(void) - \hyperlink{interface_extore_946560e5832599d861fe9c217bb71176}{clarifyErrorForRequest:receivedData:}
\begin{CompactList}\small\item\em Adds more information to to an error if possible. \item\end{CompactList}\item 
\hypertarget{interface_extore_218ecd26a58b3165a0dfb965458ad7d5}{
(BOOL) - \hyperlink{interface_extore_218ecd26a58b3165a0dfb965458ad7d5}{dateRef1970Not2001}}
\label{interface_extore_218ecd26a58b3165a0dfb965458ad7d5}

\begin{CompactList}\small\item\em Returns YES is the receiver's extore stores dates relative to the unix 1970 reference and NO if it stores dates relative to the Macintosh 2001 reference. \item\end{CompactList}\item 
(NSMutableDictionary $\ast$) - \hyperlink{interface_extore_8b77fe152f7e716402bc928764c7404d}{defaultFileProperties}
\begin{CompactList}\small\item\em Returns a dictionary of default file properties for the receiver. \item\end{CompactList}\item 
\hypertarget{interface_extore_1ce769dd6f033dd907797eb007af7247}{
(NSString $\ast$) - \hyperlink{interface_extore_1ce769dd6f033dd907797eb007af7247}{defaultProfileName}}
\label{interface_extore_1ce769dd6f033dd907797eb007af7247}

\begin{CompactList}\small\item\em Returns the default profile name for the receiver's ownerApp, or nil if the receiver's ownerApp does not use profiles. \item\end{CompactList}\item 
(NSDate $\ast$) - \hyperlink{interface_extore_3cee057ea939714b0cab7af40b4da320}{externallyDerivedLastKnownTouch}
\begin{CompactList}\small\item\em Returns the last date that the external store was touched, according to externally-derived data. \item\end{CompactList}\item 
(const ExtoreConstants $\ast$) - \hyperlink{interface_extore_de1ea933350748365537797e1ae417cb}{extoreConstants\_\-p}
\begin{CompactList}\small\item\em Returns a pointer to the all-important struct of constants that define the behavior for any particular subclass. \item\end{CompactList}\item 
\hypertarget{interface_extore_124da48b6c6136f77088f1c592cd8607}{
(id) - \textbf{extoreItemFromStark:}}
\label{interface_extore_124da48b6c6136f77088f1c592cd8607}

\item 
\hypertarget{interface_extore_74a0bd5686a3c1ebb8155f582e445a6a}{
(NSString $\ast$) - \textbf{filePathTempDebugForPath:}}
\label{interface_extore_74a0bd5686a3c1ebb8155f582e445a6a}

\item 
(NSString $\ast$) - \hyperlink{interface_extore_8aac2a63a724709e9d4fec72c08fbdc3}{freshExidForStark:tryHard:}
\begin{CompactList}\small\item\em Returns a new and different stark exid for a stark which is unique among the receiver's starks. \item\end{CompactList}\item 
\hypertarget{interface_extore_849fedde95de78ceef6662ecee10fb40}{
(void) - \textbf{initializeOptionalDebugDump}}
\label{interface_extore_849fedde95de78ceef6662ecee10fb40}

\item 
(id) - \hyperlink{interface_extore_ba2c0ecbf05f23a52a89203bc867fbdb}{initWithBrowfile:bookshelf:deference:}
\begin{CompactList}\small\item\em Designated Initializer. \item\end{CompactList}\item 
(NSDate $\ast$) - \hyperlink{interface_extore_7be9de7ee8c56abb9a183319a9cd919c}{lastDateExternalWasTouched}
\begin{CompactList}\small\item\em Returns the last date that the external store was possibly modified. \item\end{CompactList}\item 
(BOOL) - \hyperlink{interface_extore_c27400470db292f19c9fa72d106e0d27}{localMocExists}
\begin{CompactList}\small\item\em Returns whether or not the store's local managed object context exists in the hard disk. \item\end{CompactList}\item 
(BOOL) - \hyperlink{interface_extore_a8b1ac75612e56cf9dee1d79354339ec}{localMocIsSyncedWithExternal}
\begin{CompactList}\small\item\em Returns whether or not the external store was touched since the receiver last internalized the external store's data. \item\end{CompactList}\item 
\hypertarget{interface_extore_ce9e9277b7b850d4bd157274f817742b}{
(BOOL) - \hyperlink{interface_extore_ce9e9277b7b850d4bd157274f817742b}{normalizesURLs}}
\label{interface_extore_ce9e9277b7b850d4bd157274f817742b}

\begin{CompactList}\small\item\em Returns whether or not the receiver's ownerApp normalizese URLs that are written to it. \item\end{CompactList}\item 
\hypertarget{interface_extore_50b45081f7fe9447e65aaf2edb69ecda}{
(NSString $\ast$) - \hyperlink{interface_extore_50b45081f7fe9447e65aaf2edb69ecda}{ownerAppDisplayName}}
\label{interface_extore_50b45081f7fe9447e65aaf2edb69ecda}

\begin{CompactList}\small\item\em A name for displaying the exformat to the user interface: window title bars, dialogs, AppleScript, etc. Usually, this is the same as the ownerApp. \item\end{CompactList}\item 
\hypertarget{interface_extore_b0739c718e3c654555b08d76f104dcb4}{
(BOOL) - \hyperlink{interface_extore_b0739c718e3c654555b08d76f104dcb4}{ownerAppIsLocalApp}}
\label{interface_extore_b0739c718e3c654555b08d76f104dcb4}

\begin{CompactList}\small\item\em Returns YES if the receiver's ownerApp is a desktop application and NO if it is a web application. \item\end{CompactList}\item 
\hypertarget{interface_extore_0796df4147716258215ad5e8753fc610}{
(OwnerAppNiceness) - \hyperlink{interface_extore_0796df4147716258215ad5e8753fc610}{ownerAppNiceness}}
\label{interface_extore_0796df4147716258215ad5e8753fc610}

\begin{CompactList}\small\item\em Returns a number which indicates how the receiver's ownerApp tolerates reading or writing its bookmarks while it is running. \item\end{CompactList}\item 
(BOOL) - \hyperlink{interface_extore_47a224dbad541909b2eecfb8df574ce0}{ownerAppWillAcceptURL:}
\begin{CompactList}\small\item\em Returns whether or not the owner web app will accept a stark with a given URL. \item\end{CompactList}\item 
(BOOL) - \hyperlink{interface_extore_07cf77d7e813e0a41d75f0ce2e0ecd63}{quillBrowserIfNeededForRequirement:}
\begin{CompactList}\small\item\em If a given requirement requires that this extore's ownerApp be not running, either asks, quits or kills it according to this extore's deference. \item\end{CompactList}\item 
(BOOL) - \hyperlink{interface_extore_5e7fc57328b1d851273031d218cba1e7}{readExternalDoingPrereqs}
\begin{CompactList}\small\item\em Reads bookmarks data from the external store, checking prerequisites and performing related housekeeping operations. \item\end{CompactList}\item 
(BOOL) - \hyperlink{interface_extore_f6be2ea55817100bf02e97ce5163bb4c}{readExternalNoPrereqs}
\begin{CompactList}\small\item\em Gets bookmarks data from the external store and writes Starks to the receiver's transMoc and to its localMoc (the latter only if this extore uses it), assuming prerequisites have already been verified. \item\end{CompactList}\item 
\hypertarget{interface_extore_6109b384d7a013745c4e89188c35db54}{
(void) - \textbf{recursivelyPerformSelector:onRootStark:withObject:}}
\label{interface_extore_6109b384d7a013745c4e89188c35db54}

\item 
\hypertarget{interface_extore_68c2a15a60c4f2dec09600bd1d5e1f77}{
(BOOL) - \hyperlink{interface_extore_68c2a15a60c4f2dec09600bd1d5e1f77}{shouldGenerateExidsPreWriting}}
\label{interface_extore_68c2a15a60c4f2dec09600bd1d5e1f77}

\begin{CompactList}\small\item\em Returns whether or not the receiver's \hyperlink{interface_extore}{Extore} can and should generate exids (external identifiers) for arbitrary new items before writing them to the external store/server. \item\end{CompactList}\item 
\hypertarget{interface_extore_09406eb19083fd7d04f0be894ca332f7}{
(BOOL) - \hyperlink{interface_extore_09406eb19083fd7d04f0be894ca332f7}{silentlyRemovesDuplicates}}
\label{interface_extore_09406eb19083fd7d04f0be894ca332f7}

\begin{CompactList}\small\item\em Returns whether or not the receiver's ownerApp silently removes duplicate bookmarks that are written to it. \item\end{CompactList}\item 
\hypertarget{interface_extore_9d9f6ff81b52e5c2d3b8148e1755841d}{
(NSSet $\ast$) - \hyperlink{interface_extore_9d9f6ff81b52e5c2d3b8148e1755841d}{supportedAttributes}}
\label{interface_extore_9d9f6ff81b52e5c2d3b8148e1755841d}

\begin{CompactList}\small\item\em Returns a set of strings, the stark attributes that are supported by the external store of the receiver. \item\end{CompactList}\item 
(BOOL) - \hyperlink{interface_extore_9becd1f40fdc23e9f990d91cb0a33c23}{supportedAttributesAreEqualComparingStark:otherStark:}
\begin{CompactList}\small\item\em Compares each of the attributes values which are supported by the receiver between two starks. \item\end{CompactList}\item 
(void) - \hyperlink{interface_extore_d6fbfaa09879471a7bf59c6affaf5a3f}{tweakBrowserPrefsInfo:}
\begin{CompactList}\small\item\em Subclasses override this method to do any tweaking to the preferences of the owning local app which may be required as a prerequisite to writing bookmarks. \item\end{CompactList}\item 
(void) - \hyperlink{interface_extore_ac4ac7ee256c415c8774a0882204db8a}{tweakForExtoreStark:}
\begin{CompactList}\small\item\em Subclasses override this method to do any tweaking to the properties of starks which may be required as a prerequisite to writing bookmarks. \item\end{CompactList}\item 
\hypertarget{interface_extore_2c62641ebcd2739987c8e9199f37f359}{
(NSSet $\ast$) - \hyperlink{interface_extore_2c62641ebcd2739987c8e9199f37f359}{unsupportedGenericAttributes}}
\label{interface_extore_2c62641ebcd2739987c8e9199f37f359}

\begin{CompactList}\small\item\em Returns a set of strings, the stark attributes in -\mbox{[}\hyperlink{class_stark}{Stark} genericAttributes\mbox{]} that are not supported by the external store of the receiver. \item\end{CompactList}\item 
(BOOL) - \hyperlink{interface_extore_787b6cca3e9f4b3b146d1742407106d0}{validateExid:forStark:}
\begin{CompactList}\small\item\em Checks whether a given exid is valid for a given star,. \item\end{CompactList}\item 
\hypertarget{interface_extore_106753019df89023ca5b521745799bed}{
(NSString $\ast$) - \hyperlink{interface_extore_106753019df89023ca5b521745799bed}{webHostName}}
\label{interface_extore_106753019df89023ca5b521745799bed}

\begin{CompactList}\small\item\em The name of the web host; i.e. \char`\"{}x.y.com\char`\"{} which is the external store for the receiver. \item\end{CompactList}\item 
(BOOL) - \hyperlink{interface_extore_4ecd109488a9ec90873664cfa135274b}{writeData:toFile:}
\begin{CompactList}\small\item\em Writes data to a file atomically. \item\end{CompactList}\item 
(BOOL) - \hyperlink{interface_extore_4e8e6bec443d539e2a9abafe0675d469}{writeExternalNoPrereqs}
\begin{CompactList}\small\item\em Assuming prerequisites have already been verified, writes bookmarks data from the receiver's transMoc to its external store, or if the store has a localMoc, compares the transMoc to the localMoc and writes changes to the localMoc and to the external store. \item\end{CompactList}\end{CompactItemize}
\subsection*{Static Public Member Functions}
\begin{CompactItemize}
\item 
(BOOL) + \hyperlink{interface_extore_6bf46b7499d9e8a85ac93484f6a014a2}{canAddParentNamesAsTagsExtore1:extore2:bilateral:localizedTitle:}
\begin{CompactList}\small\item\em \item\end{CompactList}\item 
(BOOL) + \hyperlink{interface_extore_be2171967a4aab345cea6e474b59bb62}{canCreateFoldersFromTagsExtore1:extore2:bilateral:localizedTitle:}
\begin{CompactList}\small\item\em \item\end{CompactList}\item 
(BOOL) + \hyperlink{interface_extore_7f5c439e4881f6c1b6182f3785e4bffc}{canProbablyInternalizeFileType:data:}
\begin{CompactList}\small\item\em Determines whether or not the receiver can probably internalize given data from a given file type. \item\end{CompactList}\item 
(const ExtoreConstants $\ast$) + \hyperlink{interface_extore_4913baf3359ce52b772e39a1831b5201}{constants\_\-p}
\begin{CompactList}\small\item\em Returns a pointer to a const struct of constants that define the workings of a particular \hyperlink{interface_extore}{Extore} subclass. \item\end{CompactList}\item 
(NSArray $\ast$) + \hyperlink{interface_extore_78925fdfe8c682889841a58c0582feee}{despoofedOrNilTagArrayFromTagArray:}
\begin{CompactList}\small\item\em Given a tag array, if delimiter spoofs are found, replaces them and returns the new array.~ Otherwise, returns nil. \item\end{CompactList}\item 
(Class) + \hyperlink{interface_extore_d9a11da9d9cf35532339abab2957cb5a}{extoreClassForExformat:}
\begin{CompactList}\small\item\em Returns the \hyperlink{interface_extore}{Extore} subclass for a given exformat. \item\end{CompactList}\item 
(id) + \hyperlink{interface_extore_11ba46870880926c6777975f3b05fc85}{extoreWithBrowfile:bookshelf:deference:}
\begin{CompactList}\small\item\em Convenience method for returning an autoreleased extore of the subclass given by the browfile's -extoreClass. \item\end{CompactList}\item 
(NSSet $\ast$) + \hyperlink{interface_extore_dc51843919f6fd49570590415476a26e}{hartainerSharypesTakingAnyStark}
\begin{CompactList}\small\item\em Returns a set of Sharypes, short values wrapped in NSNumbers, which will take any stark. \item\end{CompactList}\item 
(NSString $\ast$) + \hyperlink{interface_extore_292b6f73eece76188184a96db21718e0}{legendForKey:}
\begin{CompactList}\small\item\em Returns a short string, formatted as a table, which shows the different names used by different extores for a given stark attribute. \item\end{CompactList}\item 
\hypertarget{interface_extore_1da8cffe19e51230619048963ba17697}{
(BOOL) + \hyperlink{interface_extore_1da8cffe19e51230619048963ba17697}{rootLeavesOk}}
\label{interface_extore_1da8cffe19e51230619048963ba17697}

\begin{CompactList}\small\item\em Returns whether or not the receiver accepts starks matching coarse type SharypeCoarseLeaf in its root. \item\end{CompactList}\item 
\hypertarget{interface_extore_8261110e52382746661c9d00ec7bd5ea}{
(BOOL) + \hyperlink{interface_extore_8261110e52382746661c9d00ec7bd5ea}{rootNotchesOk}}
\label{interface_extore_8261110e52382746661c9d00ec7bd5ea}

\begin{CompactList}\small\item\em Returns whether or not the receiver accepts starks matching coarse type SharypeCoarseNotch in its root. \item\end{CompactList}\item 
\hypertarget{interface_extore_0d064623dc646ed1d87a17a08d0a1efb}{
(BOOL) + \hyperlink{interface_extore_0d064623dc646ed1d87a17a08d0a1efb}{rootSoftainersOk}}
\label{interface_extore_0d064623dc646ed1d87a17a08d0a1efb}

\begin{CompactList}\small\item\em Returns whether or not the receiver accepts starks matching coarse type SharypeCoarseSoftainer in its root. \item\end{CompactList}\item 
\hypertarget{interface_extore_fbcfdc64818b12514516220c6ca22f21}{
(Sharype) + \hyperlink{interface_extore_fbcfdc64818b12514516220c6ca22f21}{satchAll1}}
\label{interface_extore_fbcfdc64818b12514516220c6ca22f21}

\begin{CompactList}\small\item\em Returns the hartainer Sharype which dead-end starks should be directed into as a first choice. \item\end{CompactList}\item 
\hypertarget{interface_extore_adfdf084fe3d74f47654c5bd817fbc68}{
(Sharype) + \hyperlink{interface_extore_adfdf084fe3d74f47654c5bd817fbc68}{satchAll2}}
\label{interface_extore_adfdf084fe3d74f47654c5bd817fbc68}

\begin{CompactList}\small\item\em Returns the hartainer Sharype which dead-end starks should be directed into as a second choice. \item\end{CompactList}\item 
\hypertarget{interface_extore_f6c417cb9b405d777437dc73cb8f856e}{
(BOOL) + \hyperlink{interface_extore_f6c417cb9b405d777437dc73cb8f856e}{softainersAnyRootIndex}}
\label{interface_extore_f6c417cb9b405d777437dc73cb8f856e}

\begin{CompactList}\small\item\em Returns whether or not the receiver accepts softainers above or between the hartainers in its root. \item\end{CompactList}\item 
(BOOL) + \hyperlink{interface_extore_39dd1d10d68911f0be863a40586c3eca}{supportsAttribute:}
\begin{CompactList}\small\item\em Returns whether or not the receiver supports a given attribute. \item\end{CompactList}\item 
(NSArray $\ast$) + \hyperlink{interface_extore_63991341a26ccad9235ed7fa738cf6c0}{tagArrayFromString:}
\begin{CompactList}\small\item\em Parses a string and returns the tags found as an NSSet. \item\end{CompactList}\item 
(NSString $\ast$) + \hyperlink{interface_extore_113bfc8bea7708b7a19854cf16534c43}{tagDelimiter}
\begin{CompactList}\small\item\em Returns the constant tag delimiter for this extore's exformat. \item\end{CompactList}\item 
(NSString $\ast$) + \hyperlink{interface_extore_1a5a64656265e453df3646bcfa31d7f5}{tagStringFromArray:}
\begin{CompactList}\small\item\em Returns a string containing the tags in a given array. \item\end{CompactList}\end{CompactItemize}
\subsection*{Properties}
\begin{CompactItemize}
\item 
\hypertarget{interface_extore_d1d263fc25433df5ed035d5b4015a8e0}{
\hyperlink{class_bookshelf}{Bookshelf} $\ast$ \textbf{bookshelf}}
\label{interface_extore_d1d263fc25433df5ed035d5b4015a8e0}

\item 
\hypertarget{interface_extore_335c4a9b7473a5a8edeb874148d944c6}{
\hyperlink{interface_browfile}{Browfile} $\ast$ \textbf{browfile}}
\label{interface_extore_335c4a9b7473a5a8edeb874148d944c6}

\item 
\hypertarget{interface_extore_c0de8d70de66f7a494d1bd813be37f19}{
BkmxDeference \hyperlink{interface_extore_c0de8d70de66f7a494d1bd813be37f19}{deference}}
\label{interface_extore_c0de8d70de66f7a494d1bd813be37f19}

\begin{CompactList}\small\item\em Specifies how the receiver will handle if a nasty browser is running when an operation requiring it to be quit is performed. \item\end{CompactList}\item 
\hypertarget{interface_extore_66eb629a592fdb1ad706bc2c2e6c39a7}{
NSString $\ast$ \textbf{dumpPath}}
\label{interface_extore_66eb629a592fdb1ad706bc2c2e6c39a7}

\item 
NSError $\ast$ \hyperlink{interface_extore_6c3d2fcbfe56594044cea469e48ddf2a}{error}
\begin{CompactList}\small\item\em The receiver's error object. \item\end{CompactList}\item 
\hypertarget{interface_extore_a86b1d4413422fa9da109fd19d525e7c}{
NSMutableDictionary $\ast$ \textbf{fileProperties}}
\label{interface_extore_a86b1d4413422fa9da109fd19d525e7c}

\item 
\hypertarget{interface_extore_8855635de003da08b1eafe697554e1b7}{
NSManagedObjectContext $\ast$ \textbf{localMoc}}
\label{interface_extore_8855635de003da08b1eafe697554e1b7}

\item 
\hypertarget{interface_extore_2818e252968fe4371e6a7419225fb29a}{
\hyperlink{interface_starker}{Starker} $\ast$ \textbf{localStarker}}
\label{interface_extore_2818e252968fe4371e6a7419225fb29a}

\item 
\hypertarget{interface_extore_e2265e2535ace4b92ab98d0a448b15e8}{
SSYProgressView $\ast$ \textbf{progressView}}
\label{interface_extore_e2265e2535ace4b92ab98d0a448b15e8}

\item 
\hypertarget{interface_extore_38410b9cf8659283d147ae68d91a9cbd}{
NSString $\ast$ \textbf{serverPassword}}
\label{interface_extore_38410b9cf8659283d147ae68d91a9cbd}

\item 
\hypertarget{interface_extore_6b23698e40961da4e2381862367f10a8}{
\hyperlink{interface_starker}{Starker} $\ast$ \textbf{starker}}
\label{interface_extore_6b23698e40961da4e2381862367f10a8}

\item 
\hypertarget{interface_extore_dc0044be9831c73dbd549dc30be56f1d}{
NSManagedObjectContext $\ast$ \textbf{transMoc}}
\label{interface_extore_dc0044be9831c73dbd549dc30be56f1d}

\end{CompactItemize}


\subsection{Detailed Description}
Reads/Writes bookmarks from/to an external store. 



\subsection{Member Function Documentation}
\hypertarget{interface_extore_6bf46b7499d9e8a85ac93484f6a014a2}{
\index{Extore@{Extore}!canAddParentNamesAsTagsExtore1:extore2:bilateral:localizedTitle:@{canAddParentNamesAsTagsExtore1:extore2:bilateral:localizedTitle:}}
\index{canAddParentNamesAsTagsExtore1:extore2:bilateral:localizedTitle:@{canAddParentNamesAsTagsExtore1:extore2:bilateral:localizedTitle:}!Extore@{Extore}}
\subsubsection[{canAddParentNamesAsTagsExtore1:extore2:bilateral:localizedTitle:}]{\setlength{\rightskip}{0pt plus 5cm}+ (BOOL) canAddParentNamesAsTagsExtore1: ({\bf Extore}$\ast$) {\em sourceBrowfile}\/ extore2: ({\bf Extore}$\ast$) {\em destinBrowfile}\/ bilateral: (BOOL) {\em bilateral}\/ localizedTitle: (NSString$\ast$$\ast$) {\em hdlLocalizedTitle}}}
\label{interface_extore_6bf46b7499d9e8a85ac93484f6a014a2}




\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em sourceBrowfile}]If nil, will assume that it is hierarchical \item[{\em destinBrowfile}]\item[{\em bilateral}]If YES, will check both directions \item[{\em hdlLocalizedTitle}]\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]\end{Desc}
\hypertarget{interface_extore_be2171967a4aab345cea6e474b59bb62}{
\index{Extore@{Extore}!canCreateFoldersFromTagsExtore1:extore2:bilateral:localizedTitle:@{canCreateFoldersFromTagsExtore1:extore2:bilateral:localizedTitle:}}
\index{canCreateFoldersFromTagsExtore1:extore2:bilateral:localizedTitle:@{canCreateFoldersFromTagsExtore1:extore2:bilateral:localizedTitle:}!Extore@{Extore}}
\subsubsection[{canCreateFoldersFromTagsExtore1:extore2:bilateral:localizedTitle:}]{\setlength{\rightskip}{0pt plus 5cm}+ (BOOL) canCreateFoldersFromTagsExtore1: ({\bf Extore}$\ast$) {\em sourceBrowfile}\/ extore2: ({\bf Extore}$\ast$) {\em destinBrowfile}\/ bilateral: (BOOL) {\em bilateral}\/ localizedTitle: (NSString$\ast$$\ast$) {\em hdlLocalizedTitle}}}
\label{interface_extore_be2171967a4aab345cea6e474b59bb62}




\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em sourceBrowfile}]\item[{\em destinBrowfile}]If nil, will assume that it is hierarchical \item[{\em bilateral}]If YES, will check both directions \item[{\em hdlLocalizedTitle}]\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]\end{Desc}
\hypertarget{interface_extore_7f5c439e4881f6c1b6182f3785e4bffc}{
\index{Extore@{Extore}!canProbablyInternalizeFileType:data:@{canProbablyInternalizeFileType:data:}}
\index{canProbablyInternalizeFileType:data:@{canProbablyInternalizeFileType:data:}!Extore@{Extore}}
\subsubsection[{canProbablyInternalizeFileType:data:}]{\setlength{\rightskip}{0pt plus 5cm}+ (BOOL) canProbablyInternalizeFileType: (id) {\em type}\/ data: (id) {\em data}}}
\label{interface_extore_7f5c439e4881f6c1b6182f3785e4bffc}


Determines whether or not the receiver can probably internalize given data from a given file type. 

Subclasses should override. The default implementation returns NO. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em type}]The document type, in the context of NSOpenPanel, which means the filename extension, without the \char`\"{}dot\char`\"{}.\item[{\em data}]The data in the file \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]YES if it is probable, NO if impossible \end{Desc}
\hypertarget{interface_extore_946560e5832599d861fe9c217bb71176}{
\index{Extore@{Extore}!clarifyErrorForRequest:receivedData:@{clarifyErrorForRequest:receivedData:}}
\index{clarifyErrorForRequest:receivedData:@{clarifyErrorForRequest:receivedData:}!Extore@{Extore}}
\subsubsection[{clarifyErrorForRequest:receivedData:}]{\setlength{\rightskip}{0pt plus 5cm}- (void) clarifyErrorForRequest: (NSString$\ast$) {\em subpathQuery}\/ receivedData: (NSData$\ast$) {\em data}}}
\label{interface_extore_946560e5832599d861fe9c217bb71176}


Adds more information to to an error if possible. 

Specific error domains and error code combinations may be supported. \hypertarget{interface_extore_4913baf3359ce52b772e39a1831b5201}{
\index{Extore@{Extore}!constants\_\-p@{constants\_\-p}}
\index{constants\_\-p@{constants\_\-p}!Extore@{Extore}}
\subsubsection[{constants\_\-p}]{\setlength{\rightskip}{0pt plus 5cm}+ (const ExtoreConstants $\ast$) constants\_\-p }}
\label{interface_extore_4913baf3359ce52b772e39a1831b5201}


Returns a pointer to a const struct of constants that define the workings of a particular \hyperlink{interface_extore}{Extore} subclass. 

Must be overridden by subclasses. Default implementation raises an exception so do not invoke it. \hypertarget{interface_extore_8b77fe152f7e716402bc928764c7404d}{
\index{Extore@{Extore}!defaultFileProperties@{defaultFileProperties}}
\index{defaultFileProperties@{defaultFileProperties}!Extore@{Extore}}
\subsubsection[{defaultFileProperties}]{\setlength{\rightskip}{0pt plus 5cm}- (NSMutableDictionary $\ast$) defaultFileProperties }}
\label{interface_extore_8b77fe152f7e716402bc928764c7404d}


Returns a dictionary of default file properties for the receiver. 

Reads this dictionary from a resource named \char`\"{}fPD\_\-XXXX.plist\char`\"{} where XXXX is the exformat of the receiver's browfile. If this resource is not found, logs an error and returns nil.

\begin{Desc}
\item[Returns:]The dictionary read from the resource, or nil. \end{Desc}
\hypertarget{interface_extore_78925fdfe8c682889841a58c0582feee}{
\index{Extore@{Extore}!despoofedOrNilTagArrayFromTagArray:@{despoofedOrNilTagArrayFromTagArray:}}
\index{despoofedOrNilTagArrayFromTagArray:@{despoofedOrNilTagArrayFromTagArray:}!Extore@{Extore}}
\subsubsection[{despoofedOrNilTagArrayFromTagArray:}]{\setlength{\rightskip}{0pt plus 5cm}+ (NSArray $\ast$) despoofedOrNilTagArrayFromTagArray: (NSArray$\ast$) {\em tags}}}
\label{interface_extore_78925fdfe8c682889841a58c0582feee}


Given a tag array, if delimiter spoofs are found, replaces them and returns the new array.~ Otherwise, returns nil. 

Tag delimiters are replaced by the underscore, \char`\"{}\_\-\char`\"{}. If no tag delimiters are found in any member of tags, returns nil. This is to allow efficient invokers to skip extra work if tags are OK as is. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em tags}]The set of tags to be checked for spoofs \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]If delimiter spoofs were found in one or more of the input tags, a copy of the input tags with all spoofs replaced. If no spoofs were found in the input tags, returns nil. \end{Desc}
\hypertarget{interface_extore_3cee057ea939714b0cab7af40b4da320}{
\index{Extore@{Extore}!externallyDerivedLastKnownTouch@{externallyDerivedLastKnownTouch}}
\index{externallyDerivedLastKnownTouch@{externallyDerivedLastKnownTouch}!Extore@{Extore}}
\subsubsection[{externallyDerivedLastKnownTouch}]{\setlength{\rightskip}{0pt plus 5cm}- (NSDate $\ast$) externallyDerivedLastKnownTouch }}
\label{interface_extore_3cee057ea939714b0cab7af40b4da320}


Returns the last date that the external store was touched, according to externally-derived data. 

Default implmentation returns the most recent file modification date of \mbox{[}self filePath\mbox{]}.~ This works for the most common case, which is if the owning browser is a local app (as opposed to a web app) that also stores bookmarks in a single file.~ In other cases, or if for any reason this date is nil, returns the current date.

Subclasses should override if an owning web app provides such a date, or if bookmarks are stored in more than one file, as with OmniWeb. \hypertarget{interface_extore_d9a11da9d9cf35532339abab2957cb5a}{
\index{Extore@{Extore}!extoreClassForExformat:@{extoreClassForExformat:}}
\index{extoreClassForExformat:@{extoreClassForExformat:}!Extore@{Extore}}
\subsubsection[{extoreClassForExformat:}]{\setlength{\rightskip}{0pt plus 5cm}+ (Class) extoreClassForExformat: (NSString$\ast$) {\em exformat}}}
\label{interface_extore_d9a11da9d9cf35532339abab2957cb5a}


Returns the \hyperlink{interface_extore}{Extore} subclass for a given exformat. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em exformat}]The exformat (external format) for which the \hyperlink{interface_extore}{Extore} subclass is desired. Should be one of the members \hyperlink{interfaceyou}{you} get from either +\mbox{[}\mbox{[}NSApp delegate\mbox{]} supportedLocalAppExformats\mbox{]} or +\mbox{[}\mbox{[}NSApp delegate\mbox{]} supportedWebAppExformats\mbox{]}. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]A Class object \end{Desc}
\hypertarget{interface_extore_de1ea933350748365537797e1ae417cb}{
\index{Extore@{Extore}!extoreConstants\_\-p@{extoreConstants\_\-p}}
\index{extoreConstants\_\-p@{extoreConstants\_\-p}!Extore@{Extore}}
\subsubsection[{extoreConstants\_\-p}]{\setlength{\rightskip}{0pt plus 5cm}- (const ExtoreConstants $\ast$) extoreConstants\_\-p }}
\label{interface_extore_de1ea933350748365537797e1ae417cb}


Returns a pointer to the all-important struct of constants that define the behavior for any particular subclass. 

Since the struct members are all constants, this method is just a convenience.~ It forwards the message to the class object. \hypertarget{interface_extore_11ba46870880926c6777975f3b05fc85}{
\index{Extore@{Extore}!extoreWithBrowfile:bookshelf:deference:@{extoreWithBrowfile:bookshelf:deference:}}
\index{extoreWithBrowfile:bookshelf:deference:@{extoreWithBrowfile:bookshelf:deference:}!Extore@{Extore}}
\subsubsection[{extoreWithBrowfile:bookshelf:deference:}]{\setlength{\rightskip}{0pt plus 5cm}+ (id) extoreWithBrowfile: ({\bf Browfile}$\ast$) {\em browfile}\/ bookshelf: ({\bf Bookshelf}$\ast$) {\em bookshelf}\/ deference: (BkmxDeference) {\em deference}}}
\label{interface_extore_11ba46870880926c6777975f3b05fc85}


Convenience method for returning an autoreleased extore of the subclass given by the browfile's -extoreClass. 

All parameters are passed to initWithBrowfile:::.~ See that method's documentation. \hypertarget{interface_extore_8aac2a63a724709e9d4fec72c08fbdc3}{
\index{Extore@{Extore}!freshExidForStark:tryHard:@{freshExidForStark:tryHard:}}
\index{freshExidForStark:tryHard:@{freshExidForStark:tryHard:}!Extore@{Extore}}
\subsubsection[{freshExidForStark:tryHard:}]{\setlength{\rightskip}{0pt plus 5cm}- (NSString $\ast$) freshExidForStark: ({\bf Stark}$\ast$) {\em item}\/ tryHard: (BOOL) {\em tryHard}}}
\label{interface_extore_8aac2a63a724709e9d4fec72c08fbdc3}


Returns a new and different stark exid for a stark which is unique among the receiver's starks. 

The default implementation returns the next UUID using CFUUID, with dashes in it. This is appropriate for Safari and Camino. Subclasses for which this is not appropriate should override. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em item}]The item for which the fresh exid is desired. Most stores ignore this parameter \item[{\em tryHard}]If getting a fresh exid would be costly, such as having to contact a remote server, tryHard tells the method whether or not to do that. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The new exid \end{Desc}
\hypertarget{interface_extore_dc51843919f6fd49570590415476a26e}{
\index{Extore@{Extore}!hartainerSharypesTakingAnyStark@{hartainerSharypesTakingAnyStark}}
\index{hartainerSharypesTakingAnyStark@{hartainerSharypesTakingAnyStark}!Extore@{Extore}}
\subsubsection[{hartainerSharypesTakingAnyStark}]{\setlength{\rightskip}{0pt plus 5cm}+ (NSSet $\ast$) hartainerSharypesTakingAnyStark }}
\label{interface_extore_dc51843919f6fd49570590415476a26e}


Returns a set of Sharypes, short values wrapped in NSNumbers, which will take any stark. 

This is a value-added version of hartainersTakingAnyStark. It does the geeky decoding. \hypertarget{interface_extore_ba2c0ecbf05f23a52a89203bc867fbdb}{
\index{Extore@{Extore}!initWithBrowfile:bookshelf:deference:@{initWithBrowfile:bookshelf:deference:}}
\index{initWithBrowfile:bookshelf:deference:@{initWithBrowfile:bookshelf:deference:}!Extore@{Extore}}
\subsubsection[{initWithBrowfile:bookshelf:deference:}]{\setlength{\rightskip}{0pt plus 5cm}- (id) initWithBrowfile: ({\bf Browfile}$\ast$) {\em browfile\_\-}\/ bookshelf: ({\bf Bookshelf}$\ast$) {\em bookshelf\_\-}\/ deference: (BkmxDeference) {\em deference\_\-}}}
\label{interface_extore_ba2c0ecbf05f23a52a89203bc867fbdb}


Designated Initializer. 

Will initialize the subclass of \hyperlink{interface_extore}{Extore} given by the browfile's -extoreClass.

Do not send this message to \hyperlink{interface_extore}{Extore} because the \hyperlink{interface_extore}{Extore} class is useless. Send it to a subclass of \hyperlink{interface_extore}{Extore}.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em browfile\_\-}]The owning \hyperlink{interface_browfile}{Browfile}, kept as a weak reference by the receiver. \item[{\em browfile}]The owning \hyperlink{class_bookshelf}{Bookshelf}, kept as a weak reference by the receiver, or nil if this extore will not be used to internalize or externalize. \item[{\em deference\_\-}]The level of deference that the receiver will use if an operation it is tasked to perform is not allowed due to a running nasty browser.\end{description}
\end{Desc}
The \hyperlink{class_bookshelf}{Bookshelf} is used as the source of starks during an externalization, and also its progressView is sent progress messages during ixternalizations. \hypertarget{interface_extore_7be9de7ee8c56abb9a183319a9cd919c}{
\index{Extore@{Extore}!lastDateExternalWasTouched@{lastDateExternalWasTouched}}
\index{lastDateExternalWasTouched@{lastDateExternalWasTouched}!Extore@{Extore}}
\subsubsection[{lastDateExternalWasTouched}]{\setlength{\rightskip}{0pt plus 5cm}- (NSDate $\ast$) lastDateExternalWasTouched }}
\label{interface_extore_7be9de7ee8c56abb9a183319a9cd919c}


Returns the last date that the external store was possibly modified. 

The result can/should be used to determine if internalization is necessary, and also if a file conflict has occurred.

Algorithmically, this method returns the latest of the possible three dates: self.externallyDerivedLastKnownTouch self.browfile.lastKnownTouch self.browfile.lastExternalized or, if none of these three dates exists, returns the current date. \hypertarget{interface_extore_292b6f73eece76188184a96db21718e0}{
\index{Extore@{Extore}!legendForKey:@{legendForKey:}}
\index{legendForKey:@{legendForKey:}!Extore@{Extore}}
\subsubsection[{legendForKey:}]{\setlength{\rightskip}{0pt plus 5cm}+ (NSString $\ast$) legendForKey: (NSString$\ast$) {\em key}}}
\label{interface_extore_292b6f73eece76188184a96db21718e0}


Returns a short string, formatted as a table, which shows the different names used by different extores for a given stark attribute. 

This string is designed to be used in a tooltip. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em key}]The attribute for which the names are desired. \end{description}
\end{Desc}
\hypertarget{interface_extore_c27400470db292f19c9fa72d106e0d27}{
\index{Extore@{Extore}!localMocExists@{localMocExists}}
\index{localMocExists@{localMocExists}!Extore@{Extore}}
\subsubsection[{localMocExists}]{\setlength{\rightskip}{0pt plus 5cm}- (BOOL) localMocExists }}
\label{interface_extore_c27400470db292f19c9fa72d106e0d27}


Returns whether or not the store's local managed object context exists in the hard disk. 

You must use this to determine file existence, because the -localMoc accessor will create one of none exists. \hypertarget{interface_extore_a8b1ac75612e56cf9dee1d79354339ec}{
\index{Extore@{Extore}!localMocIsSyncedWithExternal@{localMocIsSyncedWithExternal}}
\index{localMocIsSyncedWithExternal@{localMocIsSyncedWithExternal}!Extore@{Extore}}
\subsubsection[{localMocIsSyncedWithExternal}]{\setlength{\rightskip}{0pt plus 5cm}- (BOOL) localMocIsSyncedWithExternal }}
\label{interface_extore_a8b1ac75612e56cf9dee1d79354339ec}


Returns whether or not the external store was touched since the receiver last internalized the external store's data. 

Gets a current value for the receiver's lastDateExternalWasTouched and compares it with the constKeyLocalMocSyncs time for the receiver's browfile which is stored in user defaults. If either number is not available, returns the \char`\"{}worst case\char`\"{} answer of YES. \begin{Desc}
\item[Returns:]NO if the receiver's data is \char`\"{}out of sync\char`\"{} with the external store, YES if the receiver's data is current/OK. \end{Desc}
\hypertarget{interface_extore_47a224dbad541909b2eecfb8df574ce0}{
\index{Extore@{Extore}!ownerAppWillAcceptURL:@{ownerAppWillAcceptURL:}}
\index{ownerAppWillAcceptURL:@{ownerAppWillAcceptURL:}!Extore@{Extore}}
\subsubsection[{ownerAppWillAcceptURL:}]{\setlength{\rightskip}{0pt plus 5cm}- (BOOL) ownerAppWillAcceptURL: (NSString$\ast$) {\em url}}}
\label{interface_extore_47a224dbad541909b2eecfb8df574ce0}


Returns whether or not the owner web app will accept a stark with a given URL. 

Default implementation returns YES.~ Subclasses whose ownerApps restrict starks by URL should override this method. \hypertarget{interface_extore_07cf77d7e813e0a41d75f0ce2e0ecd63}{
\index{Extore@{Extore}!quillBrowserIfNeededForRequirement:@{quillBrowserIfNeededForRequirement:}}
\index{quillBrowserIfNeededForRequirement:@{quillBrowserIfNeededForRequirement:}!Extore@{Extore}}
\subsubsection[{quillBrowserIfNeededForRequirement:}]{\setlength{\rightskip}{0pt plus 5cm}- (BOOL) quillBrowserIfNeededForRequirement: (OwnerAppNiceness) {\em requirement}}}
\label{interface_extore_07cf77d7e813e0a41d75f0ce2e0ecd63}


If a given requirement requires that this extore's ownerApp be not running, either asks, quits or kills it according to this extore's deference. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em requirement}]The requirement \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]YES if the requirement is satisfied after completion. \end{Desc}
\hypertarget{interface_extore_5e7fc57328b1d851273031d218cba1e7}{
\index{Extore@{Extore}!readExternalDoingPrereqs@{readExternalDoingPrereqs}}
\index{readExternalDoingPrereqs@{readExternalDoingPrereqs}!Extore@{Extore}}
\subsubsection[{readExternalDoingPrereqs}]{\setlength{\rightskip}{0pt plus 5cm}- (BOOL) readExternalDoingPrereqs }}
\label{interface_extore_5e7fc57328b1d851273031d218cba1e7}


Reads bookmarks data from the external store, checking prerequisites and performing related housekeeping operations. 

If a ownerAppNiceness requirement is not satisfied, dialogs with user to allow quitting of the browser or cancelling of the operation. Sets the receiver's error if any user cancels or if anything else goes wrong. \begin{Desc}
\item[Returns:]YES if the operation was successful, otherwise NO. \end{Desc}
\hypertarget{interface_extore_f6be2ea55817100bf02e97ce5163bb4c}{
\index{Extore@{Extore}!readExternalNoPrereqs@{readExternalNoPrereqs}}
\index{readExternalNoPrereqs@{readExternalNoPrereqs}!Extore@{Extore}}
\subsubsection[{readExternalNoPrereqs}]{\setlength{\rightskip}{0pt plus 5cm}- (BOOL) readExternalNoPrereqs }}
\label{interface_extore_f6be2ea55817100bf02e97ce5163bb4c}


Gets bookmarks data from the external store and writes Starks to the receiver's transMoc and to its localMoc (the latter only if this extore uses it), assuming prerequisites have already been verified. 

Sets the receiver's error if any user cancels or if anything else goes wrong. Default implementation logs an Internal Error. Subclasses must override. \begin{Desc}
\item[Returns:]YES if the operation was successful, otherwise NO. \end{Desc}
\hypertarget{interface_extore_9becd1f40fdc23e9f990d91cb0a33c23}{
\index{Extore@{Extore}!supportedAttributesAreEqualComparingStark:otherStark:@{supportedAttributesAreEqualComparingStark:otherStark:}}
\index{supportedAttributesAreEqualComparingStark:otherStark:@{supportedAttributesAreEqualComparingStark:otherStark:}!Extore@{Extore}}
\subsubsection[{supportedAttributesAreEqualComparingStark:otherStark:}]{\setlength{\rightskip}{0pt plus 5cm}- (BOOL) supportedAttributesAreEqualComparingStark: ({\bf Stark}$\ast$) {\em stark1}\/ otherStark: ({\bf Stark}$\ast$) {\em stark2}}}
\label{interface_extore_9becd1f40fdc23e9f990d91cb0a33c23}


Compares each of the attributes values which are supported by the receiver between two starks. 

This method compares only attributes, not relationships.

Nil values are properly supported: \begin{itemize}
\item If one stark has a nil value for a given attribute and same value in the other stark is not nil, NO is returned. \item If both starks have a nil value for a given attribute, YES may be returned. \end{itemize}
There is no distinction between stark1 and stark2.

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em stark1}]\item[{\em stark2}]\end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]YES if all supported attributes in the two starks have the same values, otherwise NO. \end{Desc}
\hypertarget{interface_extore_39dd1d10d68911f0be863a40586c3eca}{
\index{Extore@{Extore}!supportsAttribute:@{supportsAttribute:}}
\index{supportsAttribute:@{supportsAttribute:}!Extore@{Extore}}
\subsubsection[{supportsAttribute:}]{\setlength{\rightskip}{0pt plus 5cm}+ (BOOL) supportsAttribute: (NSString$\ast$) {\em key}}}
\label{interface_extore_39dd1d10d68911f0be863a40586c3eca}


Returns whether or not the receiver supports a given attribute. 

\begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em key}]The key of the relevant attribute. \end{description}
\end{Desc}
\hypertarget{interface_extore_63991341a26ccad9235ed7fa738cf6c0}{
\index{Extore@{Extore}!tagArrayFromString:@{tagArrayFromString:}}
\index{tagArrayFromString:@{tagArrayFromString:}!Extore@{Extore}}
\subsubsection[{tagArrayFromString:}]{\setlength{\rightskip}{0pt plus 5cm}+ (NSArray $\ast$) tagArrayFromString: (NSString$\ast$) {\em string}}}
\label{interface_extore_63991341a26ccad9235ed7fa738cf6c0}


Parses a string and returns the tags found as an NSSet. 

This method is used in importing from browser/services that store tags as a string. The tags in 'string' are assumed to be joined by the receiver's tagDelimiter, and any whitespace adjacent to the delimiters is ignored, as are empty strings or strings of whitespace only between consecutive delimiters. Delimiter spoofs in the string must be removed or disallowed by design before invoking this method. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em string}]The string which is to be parsed for tags \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The array of tags found, an empty array if 'string' is an empty string, or nil if 'string' is nil. \end{Desc}
\hypertarget{interface_extore_113bfc8bea7708b7a19854cf16534c43}{
\index{Extore@{Extore}!tagDelimiter@{tagDelimiter}}
\index{tagDelimiter@{tagDelimiter}!Extore@{Extore}}
\subsubsection[{tagDelimiter}]{\setlength{\rightskip}{0pt plus 5cm}+ (NSString $\ast$) tagDelimiter }}
\label{interface_extore_113bfc8bea7708b7a19854cf16534c43}


Returns the constant tag delimiter for this extore's exformat. 

\begin{Desc}
\item[Returns:]The tag delimiter, a 1-character string \end{Desc}
\hypertarget{interface_extore_1a5a64656265e453df3646bcfa31d7f5}{
\index{Extore@{Extore}!tagStringFromArray:@{tagStringFromArray:}}
\index{tagStringFromArray:@{tagStringFromArray:}!Extore@{Extore}}
\subsubsection[{tagStringFromArray:}]{\setlength{\rightskip}{0pt plus 5cm}+ (NSString $\ast$) tagStringFromArray: (NSArray$\ast$) {\em set}}}
\label{interface_extore_1a5a64656265e453df3646bcfa31d7f5}


Returns a string containing the tags in a given array. 

This method is used in exporting to browser/services that store tags as a string. The tags in the returned string are joined by the receiver's tagDelimiter, (Note: Was: followed by a space). The tags are not checked for delimiter spoofs. Delimiter spoofs must be removed or disallowed by design before invoking this method. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em array}]The set of tags to be used in creating the string. Actually, this may be any set of NSString objects. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]The string containing the tags, or an empty string if set is nil or empty. \end{Desc}
\hypertarget{interface_extore_d6fbfaa09879471a7bf59c6affaf5a3f}{
\index{Extore@{Extore}!tweakBrowserPrefsInfo:@{tweakBrowserPrefsInfo:}}
\index{tweakBrowserPrefsInfo:@{tweakBrowserPrefsInfo:}!Extore@{Extore}}
\subsubsection[{tweakBrowserPrefsInfo:}]{\setlength{\rightskip}{0pt plus 5cm}- (void) tweakBrowserPrefsInfo: (NSDictionary$\ast$) {\em info}}}
\label{interface_extore_d6fbfaa09879471a7bf59c6affaf5a3f}


Subclasses override this method to do any tweaking to the preferences of the owning local app which may be required as a prerequisite to writing bookmarks. 

This is invoked during writing of bookmarks.~ It runs in a secondary thread.~ The default implementation is a no-op. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em info}]The info dictionary that is created in -\mbox{[}\hyperlink{interface_ixternalizer}{Ixternalizer} externalizeWithDeference:\mbox{]} and passed through all methods in the externalization chain. \end{description}
\end{Desc}
\hypertarget{interface_extore_ac4ac7ee256c415c8774a0882204db8a}{
\index{Extore@{Extore}!tweakForExtoreStark:@{tweakForExtoreStark:}}
\index{tweakForExtoreStark:@{tweakForExtoreStark:}!Extore@{Extore}}
\subsubsection[{tweakForExtoreStark:}]{\setlength{\rightskip}{0pt plus 5cm}- (void) tweakForExtoreStark: ({\bf Stark}$\ast$) {\em stark}}}
\label{interface_extore_ac4ac7ee256c415c8774a0882204db8a}


Subclasses override this method to do any tweaking to the properties of starks which may be required as a prerequisite to writing bookmarks. 

This is invoked during writing of bookmarks.~ The default implementation is a no-op. \hypertarget{interface_extore_787b6cca3e9f4b3b146d1742407106d0}{
\index{Extore@{Extore}!validateExid:forStark:@{validateExid:forStark:}}
\index{validateExid:forStark:@{validateExid:forStark:}!Extore@{Extore}}
\subsubsection[{validateExid:forStark:}]{\setlength{\rightskip}{0pt plus 5cm}- (BOOL) validateExid: (NSString$\ast$) {\em exid}\/ forStark: ({\bf Stark}$\ast$) {\em stark}}}
\label{interface_extore_787b6cca3e9f4b3b146d1742407106d0}


Checks whether a given exid is valid for a given star,. 

Needed for OmniWeb, in case the stark was moved among bar, menu or ohared, it will need a new unique exid.

The default implementation returns YES. \hypertarget{interface_extore_4ecd109488a9ec90873664cfa135274b}{
\index{Extore@{Extore}!writeData:toFile:@{writeData:toFile:}}
\index{writeData:toFile:@{writeData:toFile:}!Extore@{Extore}}
\subsubsection[{writeData:toFile:}]{\setlength{\rightskip}{0pt plus 5cm}- (BOOL) writeData: (NSData$\ast$) {\em data}\/ toFile: (NSString$\ast$) {\em path}}}
\label{interface_extore_4ecd109488a9ec90873664cfa135274b}


Writes data to a file atomically. 

A wrapper around -\mbox{[}NSData writeToFile:atomically\mbox{]} which first checks if the file can be written and tries to set the receiver's -error if something goes wrong. This may be used by subclasses which require simple atomic writing of bookmarks file(s) such as Safari, Camino, Opera and OmniWeb. \begin{Desc}
\item[Parameters:]
\begin{description}
\item[{\em data}]The data to be put in the file. \item[{\em path}]The path of the file to be written. \end{description}
\end{Desc}
\begin{Desc}
\item[Returns:]YES if the operation was successful, otherwise NO. \end{Desc}
\hypertarget{interface_extore_4e8e6bec443d539e2a9abafe0675d469}{
\index{Extore@{Extore}!writeExternalNoPrereqs@{writeExternalNoPrereqs}}
\index{writeExternalNoPrereqs@{writeExternalNoPrereqs}!Extore@{Extore}}
\subsubsection[{writeExternalNoPrereqs}]{\setlength{\rightskip}{0pt plus 5cm}- (BOOL) writeExternalNoPrereqs }}
\label{interface_extore_4e8e6bec443d539e2a9abafe0675d469}


Assuming prerequisites have already been verified, writes bookmarks data from the receiver's transMoc to its external store, or if the store has a localMoc, compares the transMoc to the localMoc and writes changes to the localMoc and to the external store. 

For extores that have a localMoc, since one of the prerequisites is that there be no file conflict, the localMoc is assumed to be in sync with the external store, so the same changes (additions, deletions and updates) are written to the external store as to the localMoc.~ Effort is made to keep the two in sync during the process.~ For example, if a failure occurs halfway through writing to the external store, but it is believe that the first half were written successfully, the localMoc should also be half-changed.

Sets the receiver's error if any user cancels or if anything else goes wrong.

Default implementation logs an Internal Error.~ Subclasses must override.

\begin{Desc}
\item[Returns:]YES if the operation was successful, otherwise NO. \end{Desc}


\subsection{Property Documentation}
\hypertarget{interface_extore_6c3d2fcbfe56594044cea469e48ddf2a}{
\index{Extore@{Extore}!error@{error}}
\index{error@{error}!Extore@{Extore}}
\subsubsection[{error}]{\setlength{\rightskip}{0pt plus 5cm}- (NSError $\ast$) error\hspace{0.3cm}{\tt  \mbox{[}read, write, retain\mbox{]}}}}
\label{interface_extore_6c3d2fcbfe56594044cea469e48ddf2a}


The receiver's error object. 

The receiver's error object is a convenience for methods in the class to communicate errors to one another, without having to pass around an NSError$\ast$$\ast$ argument. It should be set to nil at the beginning of a task. Since it is a declared property, conformers of this protocol may implement it simply by  error ; 

The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
/Users/jk/Documents/Programming/Projects/BookMacster/Extore.h\item 
/Users/jk/Documents/Programming/Projects/BookMacster/Extore.m\end{CompactItemize}
